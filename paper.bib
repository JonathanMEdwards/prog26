@inproceedings{10.1145/543613.543644,
  author    = {Lenzerini, Maurizio},
  title     = {Data integration: a theoretical perspective},
  year      = {2002},
  isbn      = {1581135076},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  doi       = {10.1145/543613.543644},
  abstract  = {Data integration is the problem of combining data residing at different sources, and providing the user with a unified view of these data. The problem of designing data integration systems is important in current real world applications, and is characterized by a number of issues that are interesting from a theoretical point of view. This document presents on overview of the material to be presented in a tutorial on data integration. The tutorial is focused on some of the theoretical issues that are relevant for data integration. Special attention will be devoted to the following aspects: modeling a data integration application, processing queries in data integration, dealing with inconsistent data sources, and reasoning on queries.},
  booktitle = {Proceedings of the Twenty-First ACM SIGMOD-SIGACT-SIGART Symposium on Principles of Database Systems},
  pages     = {233--246},
  numpages  = {14},
  location  = {<conf-loc>, <city>Madison</city>, <state>Wisconsin</state>, </conf-loc>},
  series    = {PODS '02}
}

@online{airtable,
title = {The fastest way to build apps},
author = {Airtable},
url = {https://airtable.com},
urldate = {2023-06-01},
year = {2023}
}


@inproceedings{alanen2003,
  author    = {Marcus Alanen and
               Ivan Porres},
  editor    = {Perdita Stevens and
               Jon Whittle and
               Grady Booch},
  title     = {Difference and Union of Models},
  booktitle = {{\guillemotleft}UML{\guillemotright} 2003 - The Unified Modeling Language,
               Modeling Languages and Applications, 6th International Conference,
               San Francisco, CA, USA, October 20-24, 2003, Proceedings},
  series    = {Lecture Notes in Computer Science},
  volume    = {2863},
  pages     = {2--17},
  publisher = {Springer},
  year      = {2003},
  doi       = {10.1007/978-3-540-45221-8\_2},
  timestamp = {Tue, 24 May 2022 15:28:50 +0200},
}


@inproceedings{alcino06,
  author    = {Cunha, Alcino
               and Oliveira, Jos{\'e} Nuno
               and Visser, Joost},
  editor    = {Misra, Jayadev
               and Nipkow, Tobias
               and Sekerinski, Emil},
  title     = {Type-Safe Two-Level Data Transformation},
  booktitle = {FM 2006: Formal Methods},
  year      = {2006},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {284--299},
  abstract  = {A two-level data transformation consists of a type-level transformation of a data format coupled with value-level transformations of data instances corresponding to that format. Examples of two-level data transformations include XML schema evolution coupled with document migration, and data mappings used for interoperability and persistence.},
  isbn      = {978-3-540-37216-5}
}

@inproceedings{Alexe11,
  author    = {Alexe, Bogdan and ten Cate, Balder and Kolaitis, Phokion G. and Tan, Wang-Chiew},
  title     = {Designing and refining schema mappings via data examples},
  year      = {2011},
  isbn      = {9781450306614},
  publisher = {Association for Computing Machinery},
  url       = {https://doi.org/10.1145/1989323.1989338},
  doi       = {10.1145/1989323.1989338},
  abstract  = {A schema mapping is a specification of the relationship between a source schema and a target schema. Schema mappings are fundamental building blocks in data integration and data exchange and, as such, obtaining the right schema mapping constitutes a major step towards the integration or exchange of data. Up to now, schema mappings have typically been specified manually or have been derived using mapping-design systems that automatically generate a schema mapping from a visual specification of the relationship between two schemas. We present a novel paradigm and develop a system for the interactive design of schema mappings via data examples. Each data example represents a partial specification of the semantics of the desired schema mapping. At the core of our system lies a sound and complete algorithm that, given a finite set of data examples, decides whether or not there exists a GLAV schema mapping (i.e., a schema mapping specified by Global-and-Local-As-View constraints) that "fits" these data examples. If such a fitting GLAV schema mapping exists, then our system constructs the "most general" one. We give a rigorous computational complexity analysis of the underlying decision problem concerning the existence of a fitting GLAV schema mapping, given a set of data examples. Specifically, we prove that this problem is complete for the second level of the polynomial hierarchy, hence, in a precise sense, harder than NP-complete. This worst-case complexity analysis notwithstanding, we conduct an experimental evaluation of our prototype implementation that demonstrates the feasibility of interactively designing schema mappings using data examples. In particular, our experiments show that our system achieves very good performance in real-life scenarios.},
  booktitle = {Proceedings of the 2011 ACM SIGMOD International Conference on Management of Data},
  pages     = {133--144},
  numpages  = {12},
  keywords  = {data examples, data exchange, data integration, schema mappings},
  location  = {Athens, Greece},
  series    = {SIGMOD '11}
}

@online{AlterTable,
title={ALTER TABLE, SQL Language Reference},
url={https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/ALTER-TABLE.html#GUID-552E7373-BF93-477D-9DA3-B2C9386F2877},
author={Oracle Inc.},
year={2021},
urldate={2021-02-01}
}

@book{ambler06,
  title={Refactoring Databases: Evolutionary Database Design},
  author={Ambler, Scott W. and Sadalage, Pramod J.},
  isbn={9780321293534},
  lccn={2005031959},
  year={2006},
  publisher={Addison Wesley},
  address = {USA}
}

@article{Bancilhon81,
  author     = {Bancilhon, F. and Spyratos, N.},
  title      = {Update semantics of relational views},
  year       = {1981},
  issue_date = {Dec. 1981},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {6},
  number     = {4},
  issn       = {0362-5915},
  doi        = {10.1145/319628.319634},
  abstract   = {A database view is a portion of the data structured in a way suitable to a specific application. Updates on views must be translated into updates on the underlying database. This paper studies the translation process in the relational model.The procedure is as follows: first, a “complete” set of updates is defined such that
                together with every update the set contains a “return” update, that is, one that brings the view back to the original state;given two updates in the set, their composition is also in the set.To translate a complete set, we define a mapping called a “translator,” that associates with each view update a unique database update called a “translation.” The constraint on a translation is to take the database to a state mapping onto the updated view. The constraint on the translator is to be a morphism.We propose a method for defining translators. Together with the user-defined view, we define a “complementary” view such that the database could be computed from the view and its complement. We show that a view can have many different complements and that the choice of a complement determines an update policy. Thus, we fix a view complement and we define the translation of a given view update in such a way that the complement remains invariant (“translation under constant complement”). The main result of the paper states that, given a complete set U of view updates, U has a translator if and only if U is translatable under constant complement.},
  journal    = {ACM Transactions on Database Systems},
  month      = dec,
  pages      = {557–575},
  numpages   = {19},
  keywords   = {conceptual model, data model, data semantics, database view, relation, relational model database, update translation, view updating}
}

@inproceedings{banerjee87,
  author    = {Banerjee, Jay and Kim, Won and Kim, Hyoung-Joo and Korth, Henry F.},
  title     = {Semantics and implementation of schema evolution in object-oriented databases},
  year      = {1987},
  isbn      = {0897912365},
  publisher = {Association for Computing Machinery},
  doi       = {10.1145/38713.38748},
  booktitle = {Proceedings of the 1987 ACM SIGMOD International Conference on Management of Data},
  pages     = {311--322},
  numpages  = {12},
  location  = {San Francisco, California, USA},
  series    = {SIGMOD '87}
}

@inproceedings{barenz2020essence,
  author    = {B\"{a}renz, Manuel},
  title     = {The essence of live coding: change the program, keep the state!},
  year      = {2020},
  isbn      = {9781450381888},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  doi       = {10.1145/3427763.3428312},
  abstract  = {One rarely encounters programming languages and frameworks that provide general-purpose and type-safe hot code swap. It is demonstrated here that this is entirely possible in Haskell, by faithfully following the motto of live coding: "Change the program, keep the state."  With generic programming, one easily arrives at an automatic state migration function. The approach can be generalised to an arrowized Functional Reactive Programming framework that is parametrized by its side effects. It allows for building up complete live programs from reusable, modular components, and to separate data flow cleanly from control flow. Useful utilities for debugging and quickchecking are presented.},
  booktitle = {Proceedings of the 7th ACM SIGPLAN International Workshop on Reactive and Event-Based Languages and Systems},
  pages     = {2–14},
  numpages  = {13},
  keywords  = {Functional Reactive Programming, Livecoding},
  location  = {Virtual, USA},
  series    = {REBLS 2020}
}

@book{Barstow1984,
  title={Interactive Programming Environments},
  author={Barstow, D.R. and Guty, S.G. and Shrobe, H.E. and Sandewall, E.},
  isbn={9780070038851},
  lccn={83013572},
  series={McGraw-Hill computer science series},
  year={1984},
  publisher={McGraw-Hill},
  address = {USA}
}

@inproceedings{Basman19,
  author    = {Antranig Basman},
  editor    = {Mariana Marasoiu and Luke Church and Lindsay Marshall},
  title     = {The Naturalist's Friend - {A} case study and blueprint for pluralist data tools and infrastructure},
  booktitle = {Proceedings of the 30th Annual Workshop of the Psychology of Programming Interest Group, {PPIG} 2019, Newcastle University, UK, August 28 - 30, 2019},
  publisher = {Psychology of Programming Interest Group},
  month     = aug,
  year      = {2019},
  url       = {https://ppig.org/papers/2019-ppig-30th-basman/},
  timestamp = {Thu, 19 May 2022 16:52:59 +0200},
}

@inproceedings{beckmann2021shortening,
  title={Shortening Feedback Loops in a Live Game Development Environment},
  author={Beckmann, Tom and Krebs, Eva and Rein, Patrick and Ramson, Stefan and Hirschfeld, Robert},
  booktitle={2021 IEEE Symposium on Visual Languages and Human-Centric Computing (VL/HCC)},
  pages={1--5},
  year={2021},
  organization={IEEE}
}

@inproceedings{Berdaguer07,
  author    = {Berdaguer, Pablo and Cunha, Alcino and Pacheco, Hugo and Visser, Joost},
  title     = {Coupled schema transformation and data conversion for XML and SQL},
  year      = {2007},
  isbn      = {3540696083},
  publisher = {Springer-Verlag},
  address   = {Berlin, Heidelberg},
  doi       = {10.1007/978-3-540-69611-7_19},
  abstract  = {A two-level data transformation consists of a type-level transformation of a data format coupled with value-level transformations of data instances corresponding to that format. We have implemented a system for performing two-level transformations on XML schemas and their corresponding documents, and on SQL schemas and the databases that they describe. The core of the system consists of a combinator library for composing type-changing rewrite rules that preserve structural information and referential constraints. We discuss the implementation of the system's core library, and of its SQL and XML front-ends in the functional language Haskell. We show how the system can be used to tackle various two-level transformation scenarios, such as XML schema evolution coupled with document migration, and hierarchical-relational data mappings that convert between XML documents and SQL databases.},
  booktitle = {Proceedings of the 9th International Conference on Practical Aspects of Declarative Languages},
  pages     = {290–304},
  numpages  = {15},
  keywords  = {Haskell, SQL, XML, transformation},
  location  = {Nice, France},
  series    = {PADL'07}
}

@inproceedings{bernstein07,
  author    = {Bernstein, Philip A. and Melnik, Sergey},
  title     = {Model management 2.0: manipulating richer mappings},
  year      = {2007},
  isbn      = {9781595936868},
  publisher = {Association for Computing Machinery},
  doi       = {10.1145/1247480.1247482},
  abstract  = {Model management is a generic approach to solving problems of data programmability where precisely engineered mappings are required. Applications include data warehousing, e-commerce, object-to-relational wrappers, enterprise information integration, database portals, and report generators. The goal is to develop a model management engine that can support tools for all of these applications. The engine supports operations to match schemas, compose mappings, diff schemas, merge schemas, translate schemas into different data models, and generate data transformations from mappings.Much has been learned about model management since it was proposed seven years ago. This leads us to a revised vision that differs from the original in two main respects: the operations must handle more expressive mappings, and the runtime that executes mappings should be added as an important model management component. We review what has been learned from recent experience, explain the revised model management vision based on that experience, and identify the research problems that the revised vision opens up.},
  booktitle = {Proceedings of the 2007 ACM SIGMOD International Conference on Management of Data},
  pages     = {1--12},
  numpages  = {12},
  keywords  = {schema matching, schema mapping, schema evolution, model management, engineered mapping, data translation, data integration, data exchange},
  location  = {Beijing, China},
  series    = {SIGMOD '07}
}

@online{Bracha.history,
title={Bits of History, Words of Advice},
author={Gilad Bracha},
url={https://gbracha.blogspot.com/2020/05/bits-of-history-words-of-advice.html},
year={2020},
urldate={2020-05-01}
}

@online{Bracha05,
  title  = {Objects as Software Services},
  author = {Gilad Bracha},
  year = {2005},
  url = {http://bracha.org/objectsAsSoftwareServices.pdf},
}

@article{Brand18,
	author = {Brand, Stewart},
	journal = {Journal of Design and Science},
	year = {2018},
	month = jan,
	note = {https://jods.mitpress.mit.edu/pub/issue3-brand},
	publisher = {},
	title = {Pace {Layering}: How {Complex} {Systems} {Learn} and {Keep} {Learning}},
}

@book{Brand95,
  title={How buildings learn: What happens after they're built},
  author={Brand, Stewart},
  year={1995},
  publisher={Penguin Books},
  isbn = {9780140139969}
}


@inproceedings{Burnett14,
  author    = {Burnett, Margaret M. and Myers, Brad A.},
  title     = {Future of End-User Software Engineering: Beyond the Silos},
  year      = {2014},
  isbn      = {9781450328654},
  publisher = {Association for Computing Machinery},
  doi       = {10.1145/2593882.2593896},
  booktitle = {Future of Software Engineering Proceedings},
  pages     = {201--211},
  numpages  = {11},
  keywords  = {End-user software engineering (EUSE), end-user development},
  location  = {Hyderabad, India},
  series    = {FOSE 2014}
}

@online{Cambria,
title={Project Cambria: Translate your data with lenses},
author={Geoffrey Litt and Peter van Hardenberg and Henry Orion},
url={https://www.inkandswitch.com/cambria.html},
year={2020},
urldate={2020-10-01}
}

@inproceedings{carvalho21,
  author    = {Carvalho, Lu\'{\i}s and Seco, Jo\~{a}o Costa},
  title     = {Deep Semantic Versioning for Evolution and Variability},
  year      = {2021},
  isbn      = {9781450386890},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  doi       = {10.1145/3479394.3479416},
  booktitle = {Proceedings of the 23rd International Symposium on Principles and Practice of Declarative Programming},
  articleno = {21},
  numpages  = {13},
  keywords  = {Program evolution, Program versioning, Type system},
  location  = {Tallinn, Estonia},
  series    = {PPDP '21}
}

@InProceedings{Cascade,
title                = {Cascade: A meta-language for change, cause and effect},
author               = {van Rozen, Riemer},
booktitle            = {LIVE workshop at SPLASH'22},
year                 = 2022,
month                = nov
}

@inproceedings{chillon21,
  author    = {Chill\'{o}n, Alberto Hern\'{a}ndez and Ruiz, Diego Sevilla and Molina, Jes\'{u}s Garc\'{\i}a},
  title     = {Towards a Taxonomy of Schema Changes for NoSQL Databases: The Orion Language},
  year      = {2021},
  isbn      = {978-3-030-89021-6},
  publisher = {Springer-Verlag},
  address   = {Berlin, Heidelberg},
  doi       = {10.1007/978-3-030-89022-3_15},
  booktitle = {Conceptual Modeling: 40th International Conference, ER 2021, Virtual Event, October 18-21, 2021, Proceedings},
  pages     = {176--185},
  numpages  = {10},
  keywords  = {Domain specific language, Schema change operations, Taxonomy of changes, Schema evolution, NoSQL databases}
}

@misc{chillon22,
  title         = {A Taxonomy of Schema Changes for NoSQL Databases},
  author        = {Alberto Hern{\'a}ndez Chill{\'o}n and Meike Klettke and Diego Sevilla Ruiz and Jes{\'u}s Garc{\'i}a Molina},
  year          = {2022},
  eprint        = {2205.11660},
  archiveprefix = {arXiv},
  primaryclass  = {cs.DB}
}

@article{candel22,
  title    = {A unified metamodel for NoSQL and relational databases},
  journal  = {Information Systems},
  volume   = {104},
  pages    = {101898},
  year     = {2022},
  issn     = {0306-4379},
  doi      = {https://doi.org/10.1016/j.is.2021.101898},
  url      = {https://www.sciencedirect.com/science/article/pii/S0306437921001149},
  author   = {Carlos J. Fernández Candel and Diego {Sevilla Ruiz} and Jesús J. García-Molina},
  keywords = {Unified metamodel, NoSQL databases, Schemaless, Schema inference, Model-driven engineering},
  abstract = {The Database field is undergoing significant changes. Although relational systems are still predominant, the interest in NoSQL systems is continuously increasing. In this scenario, polyglot persistence is envisioned as the database architecture to be prevalent in the future. Therefore, database tools and systems are evolving to support several data models. Multi-model database tools normally use a generic or unified metamodel to represent schemas of the data model that they support. Such metamodels facilitate developing database utilities, as they can be built on a common representation. Also, the number of mappings required to migrate databases from a data model to another is reduced, and integrability is favored. In this paper, we present the U-Schema unified metamodel able to represent logical schemas for the four most popular NoSQL paradigms (columnar, document, key–value, and graph) as well as relational schemas. We will formally define the mappings between U-Schema and the data model defined for each database paradigm. How these mappings have been implemented and validated will be discussed, and some applications of U-Schema will be shown. To achieve flexibility to respond to data changes, most of NoSQL systems are “schema-on-read,” and the declaration of schemas is not required. Such an absence of schema declaration makes structural variability possible, i.e., stored data of the same entity type can have different structure. Moreover, data relationships supported by each data model are different; For example, document stores have aggregate objects but not relationship types, whereas graph stores offer the opposite. Through the paper, we will show how all these issues have been tackled in our approach. As far as we know, no proposal exists in the literature of a unified metamodel for relational and the NoSQL paradigms which describes how each individual data model is integrated and mapped. Our metamodel goes beyond the existing proposals by distinguishing entity types and relationship types, representing aggregation and reference relationships, and including the notion of structural variability. Our contributions also include developing schema extraction strategies for schemaless systems of each NoSQL data model, and tackling performance and scalability in the implementation for each store.}
}

 @inproceedings{chillon23 ,
  title     = {Propagating Schema Changes to Code: An Approach Based on a Unified Data Model},
  volume    = {3379},
  issn      = {1613-0073},
  booktitle = {CEUR Workshop Proceedings},
  publisher = {CEUR-WS},
  author    = {Chillón, Alberto Hernández and Molina, Jesús García and Hoyos, José Ramón and Ortín, María José},
  year      = {2023},
  keywords  = {Code update ; NoSQL databases ; Schema evolution ; Taxonomy of changes}
}


@inproceedings{Cicchetti11,
  author    = {Cicchetti, Antonio and Ciccozzi, Federico and Leveque, Thomas and Pierantonio, Alfonso},
  title     = {On the concurrent versioning of metamodels and models: challenges and possible solutions},
  year      = {2011},
  isbn      = {9781450306683},
  publisher = {Association for Computing Machinery},
  doi       = {10.1145/2000410.2000414},
  abstract  = {Model-Driven Engineering aims at shifting the focus of software development from coding to modelling in order to reduce the complexity of realizing nowadays applications. In this respect, models are expected to evolve due to refinements, improvements, bug fixes, and so forth. Because of the same reasons, also modelling languages (i.e. metamodels) are expected to be changed, even though at a different speed if compared to models. The relevant corpus of research grown up in the latest years and dealing with both these problems considers them as separate events; however, in normal practice not all the models are migrated instantaneously due to a metamodel adaptation, rather the co-adaptation is required when commits are attempted from a local workspace to the model repository, which can demand for different management policies.This paper illustrates the challenges arising in coping with concurrent metamodel and model versioning. In particular, it details a set of desired behaviours among which the user would usually select the appropriate management for the scenario into consideration together with entailed problems. Moreover, the work proposes corresponding solutions and discusses open issues.},
  booktitle = {Proceedings of the 2nd International Workshop on Model Comparison in Practice},
  pages     = {16–25},
  numpages  = {10},
  location  = {Zurich, Switzerland},
  series    = {IWMCP '11}
}

@inbook{Cleve2006,
  author    = {Cleve, Anthony
               and Hainaut, Jean-Luc},
  editor    = {L{\"a}mmel, Ralf
               and Saraiva, Jo{\~a}o
               and Visser, Joost},
  title     = {Co-transformations in Database Applications Evolution},
  booktitle = {Generative and Transformational Techniques in Software Engineering: International Summer School, GTTSE 2005, Braga, Portugal, July 4-8, 2005. Revised Papers},
  year      = {2006},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {409--421},
  abstract  = {The paper adresses the problem of consistency preservation in data intensive applications evolution. When the database structure evolves, the application programs must be changed to interface with the new schema. The latter modification can prove very complex, error prone and time consuming. We describe a comprehensive transformation/generative approach according to which automated program transformation can be derived from schema transformation. The proposal is illustrated in the particular context of database reengineering, for which a specific methodology and a prototype tool are presented. Some results of two case studies are described.},
  isbn      = {978-3-540-46235-4},
  doi       = {10.1007/11877028_17},
}

@inproceedings{Crichton2021,
  author = {Crichton, Will},
  title = {A New Medium for Communicating Research on Programming Languages},
  booktitle = {Proceedings of the workshop on Human Aspects of Types and Reasoning Assistants, SPLASH 2021},
  year = {2021},
  organization = {ACM},
  url = {https://willcrichton.net/nota/},
}

@article{curino08,
  author     = {Curino, Carlo A. and Moon, Hyun J. and Zaniolo, Carlo},
  title      = {Graceful database schema evolution: the PRISM workbench},
  year       = {2008},
  issue_date = {August 2008},
  publisher  = {VLDB Endowment},
  volume     = {1},
  number     = {1},
  issn       = {2150-8097},
  doi        = {10.14778/1453856.1453939},
  abstract   = {Supporting graceful schema evolution represents an unsolved problem for traditional information systems that is further exacerbated in web information systems, such as Wikipedia and public scientific databases: in these projects based on multiparty cooperation the frequency of database schema changes has increased while tolerance for downtimes has nearly disappeared. As of today, schema evolution remains an error-prone and time-consuming undertaking, because the DB Administrator (DBA) lacks the methods and tools needed to manage and automate this endeavor by (i) predicting and evaluating the effects of the proposed schema changes, (ii) rewriting queries and applications to operate on the new schema, and (iii) migrating the database.Our PRISM system takes a big first step toward addressing this pressing need by providing: (i) a language of Schema Modification Operators to express concisely complex schema changes, (ii) tools that allow the DBA to evaluate the effects of such changes, (iii) optimized translation of old queries to work on the new schema version, (iv) automatic data migration, and (v) full documentation of intervened changes as needed to support data provenance, database flash back, and historical queries. PRISM solves these problems by integrating recent theoretical advances on mapping composition and invertibility, into a design that also achieves usability and scalability. Wikipedia and its 170+ schema versions provided an invaluable testbed for validating PRISM tools and their ability to support legacy queries.},
  journal    = {Proceedings VLDB Endowment},
  month      = aug,
  pages      = {761--772},
  numpages   = {12}
}


@online{daff,
title={daff},
author={Fitz, Paul},
url={https://paulfitz.github.io/daff/},
year={2021},
urldate={2021-07-01}
}

@inproceedings{DBLP:conf/pldi/OmarMBVCC21,
  author    = {Cyrus Omar and
               David Moon and
               Andrew Blinn and
               Ian Voysey and
               Nick Collins and
               Ravi Chugh},
  editor    = {Stephen N. Freund and
               Eran Yahav},
  title     = {Filling typed holes with live GUIs},
  booktitle = {{PLDI} '21: 42nd {ACM} {SIGPLAN} International Conference on Programming
               Language Design and Implementation, Virtual Event, Canada, June 20-25,
               20211},
  pages     = {511--525},
  publisher = {{ACM}},
  year      = {2021},
  doi       = {10.1145/3453483.3454059},
  timestamp = {Mon, 21 Jun 2021 13:42:02 +0200},
}

@article{DBLP:journals/pacmpl/LubinCOC20,
  author    = {Justin Lubin and
               Nick Collins and
               Cyrus Omar and
               Ravi Chugh},
  title     = {Program sketching with live bidirectional evaluation},
  journal   = {Proceedings of the {ACM} on Programming Languages},
  volume    = {4},
  number    = {{ICFP}},
  pages     = {109:1--109:29},
  year      = {2020},
  doi       = {10.1145/3408991},
  timestamp = {Wed, 17 Feb 2021 08:54:13 +0100},
}

@online{dbmaestro,
title={DBmaestro: DevOps for Database},
url={https://dbmaestro.com/},
year={2024},
urldate={2024-05-01}
}

@online{dedupe,
title = {What's the best way to dedupe a table?},
author = {{Stack Overflow}},
url = {https://stackoverflow.com/questions/2230295/whats-the-best-way-to-dedupe-a-table},
urldate = {2023-06-01},
year = {2023}
}

@incollection{Deutsch64,
  title = {The LISP implementation for the PDP- 1 computer},
  author = {Deutsch, L. Peter and Berkeley, Edmund C.},
  year = {1964},
  pages = {326-375},
  editor = {Berkeley, Edmund C. and Bobrow, Daniel G.},
  booktitle = {The Programming Language LISP: Its Operation and Applications},
  publisher = {MIT Press},
  address = {Cambridge, MA}
}

@article{diSessa86,
  author     = {diSessa, A. A and Abelson, H.},
  title      = {Boxer: a reconstructible computational medium},
  year       = {1986},
  issue_date = {Sept. 1986},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {29},
  number     = {9},
  issn       = {0001-0782},
  doi        = {10.1145/6592.6595},
  abstract   = {Programming is most often viewed as a way for experts to get computers to perform complex tasks efficiently and reliably. Boxer presents an alternative image—programming as a way for nonexperts to control a reconstructible medium, much like written language, but with dramatically extended interactive capabilities.},
  journal    = {Communications ACM},
  month      = sep,
  pages      = {859–868},
  numpages   = {10}
}

@online{dolt,
title={Dolt},
author={DoltHub Inc},
url={https://www.dolthub.com/},
year={2021},
urldate={2021-7-01}
}

@online{edgedb,
title = {Schema migrations},
author = {EdgeDB Inc},
url = {https://docs.edgedb.com/guides/migrations},
urldate = {2024-05-01},
year = 2024
}

@inproceedings{Ellis89,
author = {Ellis, C. A. and Gibbs, S. J.},
title = {Concurrency Control in Groupware Systems},
year = {1989},
isbn = {0897913175},
publisher = {Association for Computing Machinery},
doi = {10.1145/67544.66963},
abstract = {Groupware systems are computer-based systems that support two or more users engaged
in a common task, and that provide an interface to a shared environment. These systems
frequently require fine-granularity sharing of data and fast response times. This
paper distinguishes real-time groupware systems from other multi-user systems and
discusses their concurrency control requirements. An algorithm for concurrency control
in real-time groupware systems is then presented. The advantages of this algorithm
are its simplicity of use and its responsiveness: users can operate directly on the
data without obtaining locks. The algorithm must know some semantics of the operations.
However the algorithm's overall structure is independent of the semantic information,
allowing the algorithm to be adapted to many situations. An example application of
the algorithm to group text editing is given, along with a sketch of its proof of
correctness in this particular case. We note that the behavior desired in many of
these systems is non-serializable.},
booktitle = {Proceedings of the 1989 ACM SIGMOD International Conference on Management of Data},
pages = {399--407},
numpages = {9},
location = {Portland, Oregon, USA},
series = {SIGMOD '89}
}

@book{EMF,
  author = {Dave Steinberg and Frank Budinsky and Marcelo Paternostro and Ed Merks},
  title = {EMF: Eclipse Modeling Framework},
  year = {2008},
  publisher = {Pearson},
  address = {221 River Street, Hoboken, NJ 07030}
}

@online{Envy,
title={Smalltalk Envy FAQ},
author={Vikas Malik},
url={http://www.faqs.org/faqs/smalltalk/ENVY-faq/},
publisher={faqs.org},
year={1997},
urldate={2020-10-01}
}

@article{ERDWEG201524,
title = {Evaluating and comparing language workbenches: Existing results and benchmarks for the future},
journal = {Computer Languages, Systems {\&} Structures},
volume = {44},
pages = {24-47},
year = {2015},
note = {Special issue on the 6th and 7th International Conference on Software Language Engineering (SLE 2013 and SLE 2014)},
issn = {1477-8424},
doi = {10.1016/j.cl.2015.08.007},
author = {Sebastian Erdweg and Tijs {van der Storm} and Markus V{\"o}lter and Laurence Tratt and Remi Bosman and William R. Cook and Albert Gerritsen and Angelo Hulshout and Steven Kelly and Alex Loh and Gabri{\"e}l Konat and Pedro J. Molina and Martin Palatnik and Risto Pohjonen and Eugen Schindler and Klemens Schindler and Riccardo Solmi and Vlad Vergu and Eelco Visser and Kevin {van der Vlist} and Guido Wachsmuth and Jimi {van der Woning}},
}

@article{erhard06,
  author     = {Rahm, Erhard and Bernstein, Philip A.},
  title      = {An online bibliography on schema evolution},
  year       = {2006},
  issue_date = {December 2006},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {35},
  number     = {4},
  issn       = {0163-5808},
  doi        = {10.1145/1228268.1228273},
  abstract   = {We briefly motivate and present a new online bibliography on schema evolution, an area which has recently gained much interest in both research and practice.},
  journal    = {SIGMOD Record},
  month      = dec,
  pages      = {30--31},
  numpages   = {2}
}


@inproceedings{evolvedb,
  author    = {Eckwert, Torben and Guckert, Michael and Taentzer, Gabriele},
  title     = {EvolveDB: a tool for model driven schema evolution},
  year      = {2022},
  isbn      = {9781450394673},
  publisher = {Association for Computing Machinery},
  doi       = {10.1145/3550356.3559095},
  abstract  = {Requirements for software applications change almost continuously in all phases of the product life cycle, which leads to a constant adaption of software systems. These changes affect the domain model of the application and usually lead to necessary changes of the underlying database. As a result, the data stored in this database must also be adapted accordingly. This well-known problem is called schema evolution. Manual schema evolution with low-level SQL scripts contains both time-consuming and error-prone routine tasks and complicated operations that require expert knowledge. Automation promises significant leverage for cost savings and quality improvements. To date, the most advanced solutions for this problem have focused on operator-based approaches. However, these approaches do not allow free editing of the database schema, but require the database administrator to know in advance the exact sequence of all required operations. In this paper, we present EvolveDB, an approach to model-driven schema evolution in relational databases, where the user specifies the evolution steps by freely editing a database model extracted by reverse engineering. EvolveDB analyzes the differences between the status quo and the evolved model structures and generates a data migration script. An initial evaluation with experts shows promising results. A screencast of the demo is available at https://youtu.be/ieXmrDd2nw4.},
  booktitle = {Proceedings of the 25th International Conference on Model Driven Engineering Languages and Systems: Companion Proceedings},
  pages     = {61--65},
  numpages  = {5},
  keywords  = {model matching, model-driven reengeneering, relational databases, schema evolution},
  location  = {Montreal, Quebec, Canada},
  series    = {MODELS '22}
}

@techreport{FirstClassCopyPaste,
  author      = {Jonathan Edwards},
  title       = {First Class Copy \& Paste},
  institution = {MIT},
  year        = {2006},
  number      = {MIT-CSAIL-TR-2006-037},
  url         = {http://hdl.handle.net/1721.1/32980}
}

@online{Flash,
  title     = {Adobe Flash},
  url       = {https://en.wikipedia.org/wiki/Adobe_Flash},
  author = {Wikimedia Foundation},
  year      = {2021},
  urldate     = {2021-07-01}
}

@article{Foster2007,
  author     = {Foster, J. Nathan and Greenwald, Michael B. and Moore, Jonathan T. and Pierce, Benjamin C. and Schmitt, Alan},
  title      = {Combinators for bidirectional tree transformations: A linguistic approach to the view-update problem},
  year       = {2007},
  issue_date = {May 2007},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {29},
  number     = {3},
  issn       = {0164-0925},
  doi        = {10.1145/1232420.1232424},
  journal    = {ACM Transsctions on Programming Languages and Systems},
  month      = may,
  pages      = {17–es},
  numpages   = {65},
  keywords   = {Bidirectional programming, Harmony, XML, lenses, view update problem}
}

@online{Gemstone,
title={Gemstone Programmer's Guide: Class versions and Instance Migration},
author={GemTalk Systems},
url={https://downloads.gemtalksystems.com/docs/GemStone64/3.2.x/GS64-ProgGuide-3.2/10-ClassHistory.htm},
urldate = {2024-05-01},
year={2015}
}

@inproceedings{gitless,
  author     = {De Rosso, Santiago Perez and Jackson, Daniel},
  title      = {Purposes, Concepts, Misfits, and a Redesign of Git},
  booktitle = {Proceedings of the 2016 {ACM} {SIGPLAN} International Conference on
               Object-Oriented Programming, Systems, Languages, and Applications,
               {OOPSLA} 2016, part of {SPLASH} 2016, Amsterdam, The Netherlands,
               October 30 - November 4, 2016},
  year       = {2016},
  issue_date = {October 2016},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {51},
  number     = {10},
  issn       = {0362-1340},
  doi        = {10.1145/3022671.2984018},
  month      = oct,
  pages      = {292--310}
}

@inproceedings{perez13,
  author    = {Perez De Rosso, Santiago and Jackson, Daniel},
  title     = {What's wrong with git? a conceptual design analysis},
  year      = {2013},
  isbn      = {9781450324724},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/2509578.2509584},
  doi       = {10.1145/2509578.2509584},
  booktitle = {Proceedings of the 2013 ACM International Symposium on New Ideas, New Paradigms, and Reflections on Programming \& Software},
  pages     = {37–52},
  numpages  = {16},
  keywords  = {version control, usability, software design, git, design, conceptual modeling, conceptual integrity, concepts, concept design},
  location  = {Indianapolis, Indiana, USA},
  series    = {Onward! 2013}
}

@book{Goldberg80,
author = {Goldberg, Adele},
title = {SMALLTALK-80:  The Interactive Programming Environment},
year = {1984},
isbn = {0201113724},
publisher = {Addison-Wesley Longman Publishing Co., Inc.},
address = {USA}
}

@inproceedings{goldman2011real,
  author    = {Goldman, Max and Little, Greg and Miller, Robert C.},
  title     = {Real-time collaborative coding in a web IDE},
  year      = {2011},
  isbn      = {9781450307161},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  doi       = {10.1145/2047196.2047215},
  booktitle = {Proceedings of the 24th Annual ACM Symposium on User Interface Software and Technology},
  pages     = {155–164},
  numpages  = {10},
  keywords  = {pair programming, collaborative editing, collaboration},
  location  = {Santa Barbara, California, USA},
  series    = {UIST '11}
}



@book{Goodman87,
  title={The Complete HyperCard Handbook},
  author={Goodman, D. and Atkinson, W.},
  isbn={9780553343915},
  lccn={87201799},
  series={Bantam books},
  year={1987},
  publisher={Bantam Books},
  address={USA}
}


@online{Hammant17,
title={Smalltalk Envy},
author={Paul Hammant},
url={https://paulhammant.com/2017/09/01/smalltalk-envy/},
year={2017},
urldate={2024-05-01}
}

@phdthesis{Hancock03,
  author = {C. Hancock and M. Resnick},
  title  = {Real-time programming and the big ideas of computational literacy},
  year   = {2003},
  school  = {Massachusetts Institute of Technology},
  url = {https://dspace.mit.edu/handle/1721.1/61549}
}

@inbook{Hartung2011,
  author    = {Hartung, Michael
               and Terwilliger, James
               and Rahm, Erhard},
  editor    = {Bellahsene, Zohra
               and Bonifati, Angela
               and Rahm, Erhard},
  title     = {Recent Advances in Schema and Ontology Evolution},
  booktitle = {Schema Matching and Mapping},
  year      = {2011},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {149--190},
  abstract  = {Schema evolution is the increasingly important ability to adapt deployed schemas to changing requirements. Effective support for schema evolution is challenging since schema changes may have to be propagated, correctly and efficiently, to instance data and dependent schemas, mappings, or applications. We introduce the major requirements for effective schema and ontology evolution, including support for a rich set of change operations, simplicity of change specification, evolution transparency (e.g., by providing and maintaining views or schema versions), automated generation of evolution mappings, and predictable instance migration that minimizes data loss and manual intervention. We then give an overview about the current state of the art and recent research results for the evolution of relational schemas, XML schemas, and ontologies. For numerous approaches, we outline how and to what degree they meet the introduced requirements.},
  isbn      = {978-3-642-16518-4},
  doi       = {10.1007/978-3-642-16518-4_6},
}



@inproceedings{Hazelnut17,
  author    = {Cyrus Omar and Ian Voysey and Michael Hilton and Jonathan Aldrich and Matthew A. Hammer},
  title     = {{Hazelnut: A Bidirectionally Typed Structure Editor Calculus}},
  booktitle = {44th {ACM} {SIGPLAN} Symposium on Principles of Programming Languages ({POPL} 2017)},
  year      = {2017}
}

@article{HazelnutLive19,
  author     = {Omar, Cyrus and Voysey, Ian and Chugh, Ravi and Hammer, Matthew A.},
  title      = {Live functional programming with typed holes},
  year       = {2019},
  issue_date = {January 2019},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {3},
  number     = {POPL},
  doi        = {10.1145/3290327},
  journal    = {Proceedings of the ACM on Programming Languages},
  month      = jan,
  articleno  = {14},
  numpages   = {32},
  keywords   = {typed holes, structured editing, live programming, gradual typing, contextual modal type theory}
}

 @inproceedings{Heer2023,
  author    = {Heer, Jeffrey and Conlen, Matthew and Devireddy, Vishal and Nguyen, Tu and Horowitz, Joshua},
  title     = {Living Papers: A Language Toolkit for Augmented Scholarly Communication},
  year      = {2023},
  isbn      = {9798400701320},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  doi       = {10.1145/3586183.3606791},
  booktitle = {Proceedings of the 36th Annual ACM Symposium on User Interface Software and Technology},
  articleno = {42},
  numpages  = {13},
  keywords  = {Academic Publishing, Augmented Reading, Interactive Articles},
  location  = {San Francisco, CA, USA},
  series    = {UIST '23}
}


@inproceedings{Hempel18,
author = {Hempel, Brian and Lubin, Justin and Lu, Grace and Chugh, Ravi},
title = {Deuce: A Lightweight User Interface for Structured Editing},
year = {2018},
isbn = {9781450356381},
publisher = {Association for Computing Machinery},
doi = {10.1145/3180155.3180165},
booktitle = {Proceedings of the 40th International Conference on Software Engineering},
pages = {654--664},
numpages = {11},
keywords = {structured editing, direct manipulation, refactoring},
location = {Gothenburg, Sweden},
series = {ICSE '18}
}

@inproceedings{herrmann15,
  author    = {Herrmann, Kai
               and Voigt, Hannes
               and Behrend, Andreas
               and Lehner, Wolfgang},
  editor    = {Tadeusz, Morzy
               and Valduriez, Patrick
               and Bellatreche, Ladjel},
  title     = {CoDEL -- A Relationally Complete Language for Database Evolution},
  booktitle = {Advances in Databases and Information Systems},
  year      = {2015},
  publisher = {Springer International Publishing},
  address   = {Cham},
  pages     = {63--76},
  abstract  = {Software developers adapt to the fast-moving nature of software systems with agile development techniques. However, database developers lack the tools and concepts to keep pace. Data, already existing in a running product, needs to be evolved accordingly, usually by manually written SQL scripts. A promising approach in database research is to use a declarative database evolution language, which couples both schema and data evolution into intuitive operations. Existing database evolution languages focus on usability but did not aim for completeness. However, this is an inevitable prerequisite for reasonable database evolution to avoid complex and error-prone workarounds. We argue that relational completeness is the feasible expressiveness for a database evolution language. Building upon an existing language, we introduce CoDEL. We define its semantic using relational algebra, propose a syntax, and show its relational completeness.},
  isbn      = {978-3-319-23135-8}
}


@inproceedings{herrmann17,
  author    = {Herrmann, Kai and Voigt, Hannes and Behrend, Andreas and Rausch, Jonas and Lehner, Wolfgang},
  title     = {Living in Parallel Realities: Co-Existing Schema Versions with a Bidirectional Database Evolution Language},
  year      = {2017},
  isbn      = {9781450341974},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  doi       = {10.1145/3035918.3064046},
  booktitle = {Proceedings of the 2017 ACM International Conference on Management of Data},
  pages     = {1101–1116},
  numpages  = {16},
  keywords  = {database evolution, co-existing schema versions},
  location  = {Chicago, Illinois, USA},
  series    = {SIGMOD '17}
}

@inproceedings{Herrmannsdoerfer11,
  author    = {Herrmannsdoerfer, Markus
               and Vermolen, Sander D.
               and Wachsmuth, Guido},
  editor    = {Malloy, Brian
               and Staab, Steffen
               and van den Brand, Mark},
  title     = {An Extensive Catalog of Operators for the Coupled Evolution of Metamodels and Models},
  booktitle = {Software Language Engineering},
  year      = {2011},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {163--182},
  abstract  = {Modeling languages and thus their metamodels are subject to change. When a metamodel is evolved, existing models may no longer conform to it. Manual migration of these models in response to metamodel evolution is tedious and error-prone. To significantly automate model migration, operator-based approaches provide reusable coupled operators that encapsulate both metamodel evolution and model migration. The success of an operator-based approach highly depends on the library of reusable coupled operators it provides. In this paper, we thus present an extensive catalog of coupled operators that is based both on a literature survey as well as real-life case studies. The catalog is organized according to a number of criteria to ease assessing the impact on models as well as selecting the right operator for a metamodel change at hand.},
  isbn      = {978-3-642-19440-5}
}

@article{hicks2005dynamic,
  author     = {Hicks, Michael and Nettles, Scott},
  title      = {Dynamic software updating},
  year       = {2005},
  issue_date = {November 2005},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {27},
  number     = {6},
  issn       = {0164-0925},
  doi        = {10.1145/1108970.1108971},
  journal    = {ACM Transactiona on Programming Languages and Systems},
  month      = nov,
  pages      = {1049–1096},
  numpages   = {48},
  keywords   = {typed assembly language, Dynamic software updating}
}

@inbook{intentional,
author = {Czarnecki, Krzysztof and Eisenecker, Ulrich W.},
title = {Generative Programming: Methods, Tools, and Applications},
chapter={11},
year = {2000},
isbn = {0201309777},
publisher = {ACM Press/Addison-Wesley Publishing Co.},
address = {USA}
}

@article{JVisser08,
  author     = {Visser, Joost},
  title      = {Coupled Transformation of Schemas, Documents, Queries, and Constraints},
  year       = {2008},
  issue_date = {May, 2008},
  publisher  = {Elsevier Science Publishers B. V.},
  address    = {NLD},
  volume     = {200},
  number     = {3},
  issn       = {1571-0661},
  doi        = {10.1016/j.entcs.2008.04.090},
  abstract   = {Coupled transformation occurs when multiple software artifacts must be transformed in such a way that they remain consistent with each other. For instance, when a database schema is adapted in the context of system maintenance, the persistent data residing in the system's database needs to be migrated to conform to the adapted schema. Also, queries embedded in the application code and any declared referential constraints must be adapted to take the schema changes into account. As another example, in XML-to-relational data mapping, a hierarchical XML Schema is mapped to a relational SQL schema with appropriate referential constraints, and the XML documents and queries are converted into relational data and relational queries. The 2LT project is aimed at providing a formal basis for coupled transformation. This formal basis is found in data refinement theory, point-free program calculation, and strategic term rewriting. We formalize the coupled transformation of a data type by an algebra of information-preserving data refinement steps, each witnessed by appropriate data conversion functions. Refinement steps are modeled by so-called two-level rewrite rules on type expressions that synthesize conversion functions between redex and reduct while rewriting. Strategy combinators are used to composed two-level rewrite rules into complete rewrite systems. Point-free program calculation is applied to optimized synthesize conversion function, to migrate queries, and to normalize data type constraints. In this paper, we provide an overview of the challenges met by the 2LT project and we give a sketch of the solutions offered.},
  journal    = {Electronic Notes Theoretical Computer Science},
  month      = may,
  pages      = {3–23},
  numpages   = {21},
  keywords   = {Coupled transformation, constraint propagation, data mappings, data refinement, format evolution, model transformation, point-free program transformation, query migration, strategic term rewriting, two-level transformation}
}

@inproceedings{kandel11,
  author    = {Kandel, Sean and Paepcke, Andreas and Hellerstein, Joseph and Heer, Jeffrey},
  title     = {Wrangler: interactive visual specification of data transformation scripts},
  year      = {2011},
  isbn      = {9781450302289},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  doi       = {10.1145/1978942.1979444},
  booktitle = {Proceedings of the SIGCHI Conference on Human Factors in Computing Systems},
  pages     = {3363–3372},
  numpages  = {10},
  keywords  = {data analysis, data cleaning, transformation, visualization, wrangler},
  location  = {Vancouver, BC, Canada},
  series    = {CHI '11}
}

@inproceedings{kehrer12,
  author    = {Kehrer, Timo and Kelter, Udo and Ohrndorf, Manuel and Sollbach, Tim},
  booktitle = {2012 28th IEEE International Conference on Software Maintenance (ICSM)},
  title     = {Understanding model evolution through semantically lifting model differences with SiLift},
  year      = {2012},
  volume    = {},
  number    = {},
  pages     = {638-641},
  keywords  = {Unified modeling language;Adaptation models;Semantics;Engines;Conferences;Software;Software engineering;model comparison;model difference;semantic lifting;difference presentation},
  doi       = {10.1109/ICSM.2012.6405342}
}

@inbook{Kery17,
  author    = {Kery, Mary Beth and Horvath, Amber and Myers, Brad},
  title     = {Variolite: Supporting Exploratory Programming by Data Scientists},
  year      = {2017},
  isbn      = {9781450346559},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  doi       = {10.1145/3025453.3025626},
  abstract  = {How do people ideate through code? Using semi-structured interviews and a survey,
we studied data scientists who program, often with small scripts, to experiment with
data. These studies show that data scientists frequently code new analysis ideas by
building off of their code from a previous idea. They often rely on informal versioning
interactions like copying code, keeping unused code, and commenting out code to repurpose
older analysis code while attempting to keep those older analyses intact. Unlike conventional
version control, these informal practices allow for fast versioning of any size code
snippet, and quick comparisons by interchanging which versions are run. However, data
scientists must maintain a strong mental map of their code in order to distinguish
versions, leading to errors and confusion. We explore the needs for improving version
control tools for exploratory tasks, and demonstrate a tool for lightweight local
versioning, called Variolite, which programmers found usable and desirable in a preliminary
usability study.},
  booktitle = {Proceedings of the 2017 CHI Conference on Human Factors in Computing Systems},
  pages     = {1265--1276},
  numpages  = {12}
}


@inproceedings{diff3,
  abstract  = {The diff3 algorithm is widely considered the gold standard for merging uncoordinated changes to list-structured data such as text files. Surprisingly, its fundamental properties have never been studied in depth.},
  address   = {Berlin, Heidelberg},
  author    = {Khanna, Sanjeev and Kunal, Keshav and Pierce, Benjamin C.},
  booktitle = {FSTTCS 2007: Foundations of Software Technology and Theoretical Computer Science},
  editor    = {Arvind, V. and Prasad, Sanjiva},
  isbn      = {978-3-540-77050-3},
  pages     = {485--496},
  publisher = {Springer Berlin Heidelberg},
  title     = {A Formal Investigation of Diff3},
  year      = {2007}
}

@article{Kleppmann21,
  author  = {Kleppmann, Martin and Mulligan, Dominic P. and Gomes, Victor B. F. and Beresford, Alastair},
  journal = {IEEE Transactions on Parallel and Distributed Systems},
  title   = {A highly-available move operation for replicated trees},
  year    = {2021},
  volume  = {},
  number  = {},
  pages   = {1-1},
  doi     = {10.1109/TPDS.2021.3118603}
}


@article{klint2011easy,
  author    = {Paul Klint and
               Tijs van der Storm and
               Jurgen J. Vinju},
  editor    = {Jo{\~{a}}o M. Fernandes and
               Ralf L{\"{a}}mmel and
               Joost Visser and
               Jo{\~{a}}o Saraiva},
  title     = {{EASY} Meta-programming with Rascal},
  booktitle = {Generative and Transformational Techniques in Software Engineering
               {III} - International Summer School, {GTTSE} 2009, Braga, Portugal,
               July 6-11, 2009. Revised Papers},
  series    = {Lecture Notes in Computer Science},
  volume    = {6491},
  pages     = {222--289},
  publisher = {Springer},
  year      = {2009},
  doi       = {10.1007/978-3-642-18023-1\_6},
  timestamp = {Thu, 11 Jul 2024 20:37:25 +0200},
}

@inproceedings{Klokmose17,
author = {R\"{a}dle, Roman and Nouwens, Midas and Antonsen, Kristian and Eagan, James R. and Klokmose, Clemens N.},
title = {Codestrates: Literate Computing with Webstrates},
year = {2017},
isbn = {9781450349819},
publisher = {Association for Computing Machinery},
doi = {10.1145/3126594.3126642},
abstract = {We introduce Codestrates, a literate computing approach to developing interactive
software. Codestrates blurs the distinction between the use and development of applications.
It builds on the literate computing approach, commonly found in interactive notebooks
such as Jupyter notebook. Literate computing weaves together prose and live computation
in the same document. However, literate computing in interactive notebooks are limited
to computation and it is challenging to extend their user interface, reprogram their
functionality, or develop stand-alone applications. Codestrates builds literate computing
capabilities on top of Webstrates and demonstrates how it can be used for (i) collaborative
interactive notebooks, (ii) extending its functionality from within itself, and (iii)
developing reprogrammable applications.},
booktitle = {Proceedings of the 30th Annual ACM Symposium on User Interface Software and Technology},
pages = {715--725},
numpages = {11},
keywords = {literate computing, interactive notebooks, real-time collaboration, reprogrammable systems, literate programming},
location = {Qu\'{e}bec City, QC, Canada},
series = {UIST '17}
}


@inproceedings{Kluyver2016,
  author    = {Thomas Kluyver and
               Benjamin Ragan{-}Kelley and
               Fernando P{\'{e}}rez and
               Brian E. Granger and
               Matthias Bussonnier and
               Jonathan Frederic and
               Kyle Kelley and
               Jessica B. Hamrick and
               Jason Grout and
               Sylvain Corlay and
               Paul Ivanov and
               Dami{\'{a}}n Avila and
               Safia Abdalla and
               Carol Willing and
               Jupyter Development Team},
  editor    = {Fernando Loizides and
               Birgit Schmidt},
  title     = {Jupyter Notebooks - a publishing format for reproducible computational
               workflows},
  booktitle = {Positioning and Power in Academic Publishing: Players, Agents and
               Agendas, 20th International Conference on Electronic Publishing, G{\"{o}}ttingen,
               Germany, June 7-9, 2016},
  pages     = {87--90},
  publisher = {{IOS} Press},
  year      = {2016},
  isbn      = {9781614996491},
  doi       = {10.3233/978-1-61499-649-1-87},
  timestamp = {Wed, 24 Feb 2021 17:49:46 +0100},
}

@inproceedings{Kolling15,
author = {K\"{o}lling, Michael and Brown, Neil C. C. and Altadmri, Amjad},
title = {Frame-Based Editing: Easing the Transition from Blocks to Text-Based Programming},
year = {2015},
isbn = {9781450337533},
publisher = {Association for Computing Machinery},
doi = {10.1145/2818314.2818331},
abstract = {Block-based programming systems, such as Scratch or Alice, are the most popular environments
for introducing young children to programming. However, mastery of text-based programming
continues to be the educational goal for students who continue to program into their
teenage years and beyond. Transitioning across the significant gap between the two
editing styles presents a difficult challenge in school-level teaching of programming.
We propose a new style of program manipulation to bridge the gap: frame-based editing.
Frame-based editing has the resistance to errors and approachability of block-based
programming while retaining the flexibility and more conventional programming semantics
of text-based programming languages. In this paper, we analyse the issues involved
in the transition from blocks to text and argue that they can be overcome by using
frame-based editing as an intermediate step. A design and implementation of a frame-based
editor is provided.},
booktitle = {Proceedings of the Workshop in Primary and Secondary Computing Education},
pages = {29--38},
numpages = {10},
keywords = {Novice programming, Editing, Frame-based editing},
location = {London, United Kingdom},
series = {WiPSCE '15}
}

@article{kurniawan2015coder,
  title    = {CodeR: Real-time Code Editor Application for Collaborative Programming},
  journal  = {Procedia Computer Science},
  publisher={Elsevier},
  volume   = {59},
  pages    = {510-519},
  year     = {2015},
  note     = {International Conference on Computer Science and Computational Intelligence (ICCSCI 2015)},
  issn     = {1877-0509},
  url      = {https://www.sciencedirect.com/science/article/pii/S1877050915020608},
  author   = {Aditya Kurniawan and Aditya Kurniawan and Christine Soesanto and Joe Erik Carla Wijaya}
}

@inproceedings{lammel16,
  author    = {L\"{a}mmel, Ralf},
  title     = {Coupled software transformations revisited},
  year      = {2016},
  isbn      = {9781450344470},
  publisher = {Association for Computing Machinery},
  doi       = {10.1145/2997364.2997366},
  abstract  = {We revisit the notion of coupled software transformations (CX) which is concerned with keeping collections of software artifacts consistent in response to changes of individual artifacts. We model scenarios of CX while we abstract from technological spaces and application domains. Our objective is to mediate between universal consistency properties of CX and test-driven validation of concrete (illustrative) CX implementations. To this end, we leverage an emerging megamodeling language LAL which is based on many- and order-sorted predicate logic with support for reuse by inlining modulo substitution. We provide a simple translation semantics for LAL so that formulae can be rendered as test cases on appropriate interpretations of the megamodel elements. Our approach has been implemented and validated in logic programming; this includes the executable language definition of LAL and test-case execution on top of illustrative CX implementations.},
  booktitle = {Proceedings of the 2016 ACM SIGPLAN International Conference on Software Language Engineering},
  pages     = {239–252},
  numpages  = {14},
  keywords  = {BX, Bidirectional transformation, CX, Coupled software transformation, Linguistic architecture, Logic programming, Megamodeling, Predicate logic, Testing},
  series    = {SLE 2016},
  location  = {Amsterdam, Netherlands}
}



@book{lane1998categories,
  title={Categories for the Working Mathematician},
  author={Lane, S.M.},
  isbn={9780387984032},
  lccn={97045229},
  series={Graduate Texts in Mathematics},
  year={1998},
  publisher={Springer New York}
}

@inproceedings{li99,
  author    = {Xue Li},
  title     = {A Survey of Schema Evolution in Object-Oriented Databases},
  booktitle = {{TOOLS} 1999: 31st International Conference on Technology of Object-Oriented
               Languages and Systems, 22-25 September 1999, Nanjing, China},
  pages     = {362--371},
  publisher = {{IEEE} Computer Society},
  year      = {1999},
  doi       = {10.1109/TOOLS.1999.796507}
}


@online{liquibase,
title = {Automate database change workflows with Liquibase},
author = {Liquibase},
url = {https://www.liquibase.com},
urldate = {2023-05-01},
year = {2023}
}

@online{Litt2023,
  title={Potluck: Dynamic documents as personal software},
  author={Litt, Geoffrey and Schoening, Max and Shen, Paul and Sonnentag, Paul},
  url={https://www.inkandswitch.com/potluck/},
  urldate={2024-04-29},
  year={2023}
}

@inproceedings{localfirst,
  author    = {Kleppmann, Martin and Wiggins, Adam and van Hardenberg, Peter and McGranaghan, Mark},
  title     = {Local-first software: you own your data, in spite of the cloud},
  year      = {2019},
  isbn      = {9781450369954},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  doi       = {10.1145/3359591.3359737},
  booktitle = {Proceedings of the 2019 ACM SIGPLAN International Symposium on New Ideas, New Paradigms, and Reflections on Programming and Software},
  pages     = {154–178},
  numpages  = {25},
  keywords  = {peer-to-peer communication, mobile computing, data ownership, collaboration software, CRDTs},
  location  = {Athens, Greece},
  series    = {Onward! 2019}
}

@ARTICLE {Masinter81,
author = {L. Masinter and W. Teitelman},
journal = {Computer},
title = {The Interlisp Programming Environment},
year = {1981},
volume = {14},
number = {04},
issn = {1558-0814},
pages = {25-33},
keywords = {null},
doi = {10.1109/C-M.1981.220410},
publisher = {IEEE Computer Society},
address = {Los Alamitos, CA, USA},
month = {apr}
}

@inproceedings{mcdirmid13,
  author    = {McDirmid, Sean},
  title     = {Usable live programming},
  year      = {2013},
  isbn      = {9781450324724},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  doi       = {10.1145/2509578.2509585},
  abstract  = {Programming today involves code editing mixed with bouts of debugging to get feedback on code execution. For programming to be more fluid, editing and debugging should occur concurrently as live programming. This paper describes how live execution feedback can be woven into the editor by making places in program execution, not just code, navigable so that evaluation results can be probed directly within the code editor. A pane aside the editor also traces execution with entries that are similarly navigable, enabling quick problem diagnosis. Both probes and traces are refreshed continuously during editing, and are easily configured based on debugging needs. We demonstrate the usefulness of this live programming experience with a prototype.},
  booktitle = {Proceedings of the 2013 ACM International Symposium on New Ideas, New Paradigms, and Reflections on Programming \& Software},
  pages     = {53--62},
  numpages  = {10},
  keywords  = {live programming, debugging},
  location  = {Indianapolis, Indiana, USA},
  series    = {Onward! 2013}
}

@inproceedings{meurice17,
  author    = {Meurice, Loup and Cleve, Anthony},
  booktitle = {2017 IEEE 24th International Conference on Software Analysis, Evolution and Reengineering (SANER)},
  title     = {Supporting schema evolution in schema-less NoSQL data stores},
  year      = {2017},
  volume    = {},
  number    = {},
  pages     = {457-461},
  keywords  = {Java;Data structures;Entropy;Data mining;Urban areas},
  doi       = {10.1109/SANER.2017.7884653}
}

@book{Molina08,
  author    = {Garcia-Molina, Hector and Ullman, Jeffrey D. and Widom, Jennifer},
  title     = {Database Systems: The Complete Book},
  year      = {2008},
  isbn      = {9780131873254},
  publisher = {Prentice Hall Press},
  address   = {USA},
  edition   = {2},
  abstract  = {This introduction to database systems offers a comprehensive approach, focusing on database design, database use, and implementation of database applications and database management systems. KEY TOPICS: The first half of the book provides in-depth coverage of databases from the point of view of the database designer, user, and application programmer. It covers the latest database standards SQL:1999, SQL/PSM, SQL/CLI, JDBC, ODL, and XML, with broader coverage of SQL than most other texts. The second half of the book covers databases from the point of view of the DBMS implementor, focusing on storage structures, query processing, and transaction management. The book covers the main techniques in these areas with broader coverage of query optimization than most other texts, along with advanced topics including multidimensional and bitmap indexes, distributed transactions, and information integration techniques. Ideal for professionals and students interested in database systems. A basic understanding of algebraic expressions and laws, logic, basic data structure, OOP concepts, and programming environments is implied.}
}


@inproceedings{moller20,
  author    = {M{\"o}ller, Mark Lukas
               and Scherzinger, Stefanie
               and Klettke, Meike
               and St{\"o}rl, Uta},
  editor    = {Herbaut, Nicolas
               and La Rosa, Marcello},
  title     = {Why It Is Time for Yet Another Schema Evolution Benchmark},
  booktitle = {Advanced Information Systems Engineering},
  year      = {2020},
  publisher = {Springer International Publishing},
  address   = {Cham},
  pages     = {113--125},
  abstract  = {Database schema evolution is one of the grand challenges in data management research and practice. In this paper, we survey available schema evolution benchmarks. We argue that existing benchmarks do not reflect the more recent demands on database applications, such as online data migration for high availability applications, agile release strategies, and schema changes that affect more than one data model. We conclude that a new generation of schema evolution benchmarks is called for, which reflect these new demands, especially in the context of schema evolution in NoSQL data stores.},
  isbn      = {978-3-030-58135-0}
}

@online{MPS,
title={MPS: The Domain-Specific Language Creator},
author={JetBrains s.r.o.},
url={https://www.jetbrains.com/mps/},
year={2021},
urldate={2021-07-01}
}

@online{mysqlAlterTable,
title = {MYSql ALTER TABLE Statement},
author = {Oracle Inc},
url = {https://dev.mysql.com/doc/refman/8.0/en/alter-table.html},
urldate = {2024-05-01},
year = 2024
}

@online{Nextjournal21,
  title = {Nextjournal: The notebook for reproducible research},
  author = {{Nextjournal GmbH}},
  year = {2021},
  url = {https://nextjournal.com/},
  urldate={2024-04-29}
}

@online{noms,
title={Noms},
url={https://github.com/attic-labs/noms},
author={Attic-Labs},
year={2021},
urldate={2021-05-01}
}

@online{notion,
  title = {Notion: Write, plan, organize, play},
  author = {{Notion Labs Inc.}},
  year = {2024},
  url = {https://notion.so},
  urldate = {2024-04-29}
}

@inproceedings{Oster06,
  author    = {Oster, Gerald and Molli, Pascal and Urso, Pascal and Imine, Abdessamad},
  booktitle = {2006 International Conference on Collaborative Computing: Networking, Applications and Worksharing},
  title     = {Tombstone Transformation Functions for Ensuring Consistency in Collaborative Editing Systems},
  year      = {2006},
  volume    = {},
  number    = {},
  pages     = {1-10},
  doi       = {10.1109/COLCOM.2006.361867}
}

@article{PatchTheory,
title={A Categorical Theory of Patches},
volume={298},
ISSN={1571-0661},
DOI={10.1016/j.entcs.2013.09.018},
journal={Electronic Notes in Theoretical Computer Science},
publisher={Elsevier BV},
author={Mimram, Samuel and Di Giusto, Cinzia},
year={2013},
month={Nov},
pages={283--307}
}

@article{petersohn20,
  author     = {Petersohn, Devin and Macke, Stephen and Xin, Doris and Ma, William and Lee, Doris and Mo, Xiangxi and Gonzalez, Joseph E. and Hellerstein, Joseph M. and Joseph, Anthony D. and Parameswaran, Aditya},
  title      = {Towards scalable dataframe systems},
  year       = {2020},
  issue_date = {August 2020},
  publisher  = {VLDB Endowment},
  volume     = {13},
  number     = {12},
  issn       = {2150-8097},
  doi        = {10.14778/3407790.3407807},
  abstract   = {Dataframes are a popular abstraction to represent, prepare, and analyze data. Despite the remarkable success of dataframe libraries in R and Python, dataframes face performance issues even on moderately large datasets. Moreover, there is significant ambiguity regarding dataframe semantics. In this paper we lay out a vision and roadmap for scalable dataframe systems. To demonstrate the potential in this area, we report on our experience building Modin, a scaled-up implementation of the most widely-used and complex dataframe API today, Python's pandas. With pandas as a reference, we propose a simple data model and algebra for dataframes to ground discussion in the field. Given this foundation, we lay out an agenda of open research opportunities where the distinct features of dataframes will require extending the state of the art in many dimensions of data management. We discuss the implications of signature dataframe features including flexible schemas, ordering, row/column equivalence, and data/metadata fluidity, as well as the piecemeal, trial-and-error-based approach to interacting with dataframes.},
  journal    = {Procedings VLDB Endowment},
  month      = jul,
  pages      = {2033--2046},
  numpages   = {14}
}

@online{Pijul,
  title     = {Pijul, a sound and fast distributed version control system based on a mathematical theory of asynchronous work},
  url       = {https://pijul.org/},
  year      = {2021},
  urldate     = {2021-10-01}
}

@online{planetscale,
title = {Database branching: three-way merge for schema changes},
author = {PlanetScale Inc},
url = {https://planetscale.com/blog/database-branching-three-way-merge-schema-changes},
urldate = {2024-05-01},
year = 2024
}

@online{planetscalerails,
  title   = {Zero downtime Rails migrations with the PlanetScale Rails gem},
  author  = {Countermarsh, Mike},
  url     = {https://planetscale.com/blog/zero-downtime-rails-migrations-planetscale-rails-gem},
  urldate = {2024-05-29},
  year    = {2023}
}

@book{ProGit,
  author    = {Chacon, Scott and Straub, Ben},
  title     = {Pro Git},
  year      = {2014},
  isbn      = {1484200772},
  publisher = {Apress},
  address   = {USA},
  edition   = {2nd},
}

@online{RailsMigrations,
author={Rails},
title={Ruby on Rails Guides: Migrations},
url={https://guides.rubyonrails.org/v3.2/migrations.html},
year={2021},
urldate={2021-07-01}
}

@article{Rauch_2019,
  title     = {Babylonian-style Programming: Design and Implementation of an Integration of Live Examples into General-purpose Source Code},
  volume    = {3},
  issn      = {2473-7321},
  doi       = {10.22152/programming-journal.org/2019/3/9},
  number    = {3},
  journal   = {The Art, Science, and Engineering of Programming},
  publisher = {Aspect-Oriented Software Association (AOSA)},
  author    = {Rauch, David and Rein, Patrick and Ramson, Stefan and Lincke, Jens and Hirschfeld, Robert},
  year      = {2019},
  month     = feb
}

@article{rein2018exploratory,
  author    = {Patrick Rein and
               Stefan Ramson and
               Jens Lincke and
               Robert Hirschfeld and
               Tobias Pape},
  title     = {Exploratory and Live, Programming and Coding - {A} Literature Study
               Comparing Perspectives on Liveness},
  journal   = {The Art, Science, and Engineering of Programming},
  volume    = {3},
  number    = {1},
  pages     = {1},
  year      = {2019},
  issn =  {2473-7321},
  doi       = {10.22152/PROGRAMMING-JOURNAL.ORG/2019/3/1}
}

@misc{replit,
  author = {Replit},
  title = {Replit: Build software faster},
  year = {2024},
  howpublished = {\url{https://replit.com/}},
  note = {Accessed: 2024-05-23}
}

@article{Resnick09,
author = {Resnick, Mitchel and Maloney, John and Monroy-Hern\'{a}ndez, Andr\'{e}s and Rusk, Natalie and Eastmond, Evelyn and Brennan, Karen and Millner, Amon and Rosenbaum, Eric and Silver, Jay and Silverman, Brian and Kafai, Yasmin},
title = {Scratch: Programming for All},
year = {2009},
issue_date = {November 2009},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {52},
number = {11},
issn = {0001-0782},
doi = {10.1145/1592761.1592779},
abstract = {"Digital fluency" should mean designing, creating, and remixing, not just browsing,
chatting, and interacting.},
journal = {Communications ACM},
month = nov,
pages = {60--67},
numpages = {8}
}

@inproceedings{Ressel96,
  author    = {Ressel, Matthias and Nitsche-Ruhland, Doris and Gunzenh\"{a}user, Rul},
  title     = {An Integrating, Transformation-Oriented Approach to Concurrency Control and Undo in Group Editors},
  year      = {1996},
  isbn      = {0897917650},
  publisher = {Association for Computing Machinery},
  doi       = {10.1145/240080.240305},
  booktitle = {Proceedings of the 1996 ACM Conference on Computer Supported Cooperative Work},
  pages     = {288--297},
  numpages  = {10},
  keywords  = {groupware, interaction model, concurrency control, operation transformation, group editors, group undo},
  location  = {Boston, Massachusetts, USA},
  series    = {CSCW '96}
}

@inproceedings{RuntimeConstraint,
  author    = {Tikhonova, Ulyana and Stoel, Jouke and van der Storm, Tijs and Degueule, Thomas},
  title     = {Constraint-Based Run-Time State Migration for Live Modeling},
  year      = {2018},
  isbn      = {9781450360296},
  publisher = {Association for Computing Machinery},
  doi       = {10.1145/3276604.3276611},
  abstract  = {Live modeling enables modelers to incrementally update models as they are running and get immediate feedback about the impact of their changes. Changes introduced in a model may trigger inconsistencies between the model and its run-time state (e.g., deleting the current state in a statemachine); effectively requiring to migrate the run-time state to comply with the updated model. In this paper, we introduce an approach that enables to automatically migrate such run-time state based on declarative constraints defined by the language designer. We illustrate the approach using Nextep, a meta-modeling language for defining invariants and migration constraints on run-time state models. When a model changes, Nextep employs model finding techniques, backed by a solver, to automatically infer a new run-time model that satisfies the declared constraints. We apply Nextep to define migration strategies for two DSLs, and report on its expressiveness and performance.},
  booktitle = {Proceedings of the 11th ACM SIGPLAN International Conference on Software Language Engineering},
  pages     = {108--120},
  numpages  = {13},
  keywords  = {relational model finding, DSL, live modeling, run-time state migration},
  location  = {Boston, MA, USA},
  series    = {SLE 2018}
}

@book{sadalage12,
  title     = {NoSQL Distilled: A Brief Guide to the Emerging World of Polyglot Persistence},
  author    = {Sadalage, Pramodkumar J. and Fowler, Martin},
  isbn      = {9780133036121},
  year      = {2012},
  publisher = {Pearson Education}
}

@article{Sandewall78,
author = {Sandewall, Erik},
title = {Programming in an Interactive Environment: The ``Lisp'' Experience},
year = {1978},
issue_date = {March 1978},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {10},
number = {1},
issn = {0360-0300},
doi = {10.1145/356715.356719},
journal = {ACM Computing Surveys},
month = mar,
pages = {35--71},
numpages = {37}
}


@misc{scherzinger13,
  title         = {Managing Schema Evolution in NoSQL Data Stores},
  author        = {Stefanie Scherzinger and Meike Klettke and Uta St{\"o}rl},
  year          = {2013},
  eprint        = {1308.0514},
  archiveprefix = {arXiv},
  primaryclass  = {cs.DB}
}


@inproceedings{SemanticDeltas,
  author    = {van der Storm, Tijs},
  booktitle = {2013 1st International Workshop on Live Programming (LIVE)},
  title     = {Semantic deltas for live DSL environments},
  year      = {2013},
  volume    = {},
  number    = {},
  pages     = {35-38},
  keywords  = {Semantics;DSL;Runtime;Programming;Graphical user interfaces;Merging;Debugging},
  doi       = {10.1109/LIVE.2013.6617347}
}

@techreport{Shapiro11,
  title       = {{A comprehensive study of Convergent and Commutative Replicated Data Types}},
  author      = {Shapiro, Marc and Pregui{\c c}a, Nuno and Baquero, Carlos and Zawirski, Marek},
  url         = {https://inria.hal.science/inria-00555588},
  type        = {Research Report},
  number      = {RR-7506},
  pages       = {50},
  institution = {{Inria -- Centre Paris-Rocquencourt ; INRIA}},
  year        = {2011},
  month       = Jan,
  keywords    = {eventual consistency ; optimistic replication ; replicated data types ; distributed algorithms ; distributed systems ; Data replication ; commutative operations},
  pdf         = {https://inria.hal.science/inria-00555588v1/file/techreport.pdf},
  hal_id      = {inria-00555588},
  hal_version = {v1}
}


@online{sqliteDatatypes,
title = {Datatypes In SQLite},
author = {sqlite.org},
url = {https://www.sqlite.org/datatype3.html},
urldate = {2024-05-01},
year = 2024
}


@inproceedings{storl20,
  author = {St{\"o}rl, Uta and Klettke, Meike and Scherzinger, Stefanie},
  year   = {2020},
  month  = {04},
  pages  = {},
  title  = {NoSQL Schema Evolution and Data Migration: State-of-the-Art and Opportunities (Tutorial)},
  booktitle={Proceedings of the 22nd International Conference on Extending Database Technology (EDBT)},
  issn = {2367-2005},
  doi    = {10.5441/002/edbt.2020.87}
}

@inproceedings{storl22,
  author = {St{\"o}rl, Uta and Klettke, Meike},
  year   = {2022},
  month  = {03},
  pages  = {},
  title  = {Darwin: A Data Platform for NoSQL Schema Evolution Management and Data Migration},
  booktitle = {Proceedings of the Workshops of the {EDBT/ICDT} 2022 Joint Conference, Edinburgh, UK, March 29, 2022},
  volume    = {3135},
  publisher = {CEUR-WS.org},
  url = {https://ceur-ws.org/Vol-3135/dataplat_short3.pdf}
}

@article{Subtext05,
  author     = {Edwards, Jonathan},
  title      = {Subtext: uncovering the simplicity of programming},
  year       = {2005},
  issue_date = {October 2005},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {40},
  number     = {10},
  issn       = {0362-1340},
  doi        = {10.1145/1103845.1094851},
  abstract   = {Representing programs as text strings makes programming harder then it has to be. The source text of a program is far removed from its behavior. Bridging this conceptual gulf is what makes programming so inhumanly difficult -- we are not compilers. Subtext is a new medium in which the representation of a program is the same thing as its execution. Like a spreadsheet, a program is visible and alive, constantly executing even as it is edited. Program edits are coherent semantic transformations.The essence of this new medium is copying. Programs are constructed by copying and executed by copy flow: the projection of changes through copies. The simple idea of copying develops into a rich theory of higher-order continual copying of trees. Notably absent are symbolic names, the workhorse of textual notation, replaced by immediately-bound explicit relationships. Subtext unifies traditionally distinct programming tools and concepts, and enables some novel ones. Ancestral structures are a new primitive data type that combines the features of lists and records, along with unproblematic multiple inheritance. Adaptive conditionals use first-class program edits to dynamically adapt behavior.A prototype implementation shows promise, but calls for much further research. Subtext suggests that we can make programming radically easier, if we are willing to be radical.},
  journal    = {SIGPLAN Notices},
  month      = oct,
  pages      = {505–518},
  numpages   = {14},
  keywords   = {visual programming, prototypes, non-textual programming, copying}
}


@inproceedings{Sun98CSCW,
author = {Sun, Chengzheng and Ellis, Clarence},
title = {Operational Transformation in Real-Time Group Editors: Issues, Algorithms, and Achievements},
year = {1998},
isbn = {1581130090},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/289444.289469},
doi = {10.1145/289444.289469},
booktitle = {Proceedings of the 1998 ACM Conference on Computer Supported Cooperative Work},
pages = {59--68},
numpages = {10},
keywords = {intention preservation, operational transformation, groupware, group editors, causality preservation, distributed computing, convergence, consistency maintenance},
location = {Seattle, Washington, USA},
series = {CSCW '98}
}

@article{Sun98,
  author     = {Sun, Chengzheng and Jia, Xiaohua and Zhang, Yanchun and Yang, Yun and Chen, David},
  title      = {Achieving Convergence, Causality Preservation, and Intention Preservation in Real-Time Cooperative Editing Systems},
  year       = {1998},
  issue_date = {March 1998},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {5},
  number     = {1},
  issn       = {1073-0516},
  doi        = {10.1145/274444.274447},
  abstract   = {Real-time cooperative editing systems allow multiple users to view and edit the same
text/graphic/image/multimedia document at the same time for multiple sites connected
by communication networks. Consistency maintenance is one of the most significant
challenges in designing and implementing real-time cooperative editing systems. In
this article, a consistency model, with properties of convergence, causality preservation,
and intention preservation, is proposed as a framework for consistency maintenance
in real-time cooperative editing systems. Moreover, an integrated set of schemes and
algorithms, which support the proposed consistency model, are devised and discussed
in detail. In particular, we have contributed (1) a novel generic operation transformation
control algorithm for achieving intention preservation in combination with schemes
for achieving convergence and causality preservation and (2) a pair of reversible
inclusion and exclusion transformation algorithms for stringwise operations for text
editing. An Internet-based prototype system has been built to test the feasibility
of the proposed schemes and algorithms },
  journal    = {ACM Transactions Computer-Human Interaction},
  month      = mar,
  pages      = {63--108},
  numpages   = {46},
  keywords   = {convergence, computer-supported cooperative work, intention preservation, consistency maintenance, operational transformation, cooperative editing, causality preservation, REDUCE, groupware systems}
}

@inproceedings{sutton18,
  author    = {Sutton, Charles and Hobson, Timothy and Geddes, James and Caruana, Rich},
  title     = {Data Diff: Interpretable, Executable Summaries of Changes in Distributions for Data Wrangling},
  year      = {2018},
  isbn      = {9781450355520},
  publisher = {Association for Computing Machinery},
  doi       = {10.1145/3219819.3220057},
  abstract  = {Many analyses in data science are not one-off projects, but are repeated over multiple data samples, such as once per month, once per quarter, and so on. For example, if a data scientist performs an analysis in 2017 that saves a significant amount of money, then she will likely to be asked to perform the same analysis on data from 2018. But more data analyses means more effort spent in data wrangling. We introduce the data diff problem, which attempts to turn this problem into an opportunity. Comparing the repeated data samples against each other, inconsistencies may be indicative of underlying issues in data quality. By analogy to text textttdiff, the data diff problem is to find a "patch", that is, transformation in a specified domain-specific language, that transforms the data samples so that they are identically distributed. We present a prototype tool for data diff that formalizes the problem as a bipartite matching problem, calibrating its parameters using a bootstrap procedure. The tool is evaluated quantitatively and through a case study on an open government data set.},
  booktitle = {Proceedings of the 24th ACM SIGKDD International Conference on Knowledge Discovery \& Data Mining},
  pages     = {2279--2288},
  numpages  = {10},
  keywords  = {automl, data mining, data wrangling, sequential analysis},
  location  = {London, United Kingdom},
  series    = {KDD '18}
}


@inproceedings{Swierstra14,
  author    = {Swierstra, Wouter and L\"{o}h, Andres},
  title     = {The Semantics of Version Control},
  year      = {2014},
  isbn      = {9781450332101},
  publisher = {Association for Computing Machinery},
  doi       = {10.1145/2661136.2661137},
  abstract  = {As software becomes increasingly complex, software configuration management is becoming
ever more important. This paper shows how logics for reasoning about mutable state,
such as separation logic, can also be used to give semantics for version control systems.
By applying these ideas from the programming language research community, developers
may reason formally about the broader software development process.},
  booktitle = {Proceedings of the 2014 ACM International Symposium on New Ideas, New Paradigms, and Reflections on Programming &amp; Software},
  pages     = {43--54},
  numpages  = {12},
  keywords  = {separation logic, semantics, hoare logic, version control},
  location  = {Portland, Oregon, USA},
  series    = {Onward! 2014}
}

@article{tanimoto90,
  author     = {Tanimoto, Steven L.},
  title      = {VIVA: A Visual Language for Image Processing},
  year       = {1990},
  issue_date = {June, 1990},
  publisher  = {Academic Press, Inc.},
  address    = {USA},
  volume     = {1},
  number     = {2},
  issn       = {1045-926X},
  doi        = {10.1016/S1045-926X(05)80012-6},
  journal    = {Journal of Visual Languages and Computing},
  month      = jun,
  pages      = {127--139},
  numpages   = {13}
}


@article{techdims,
  author    = {Joel Jakubovic and
               Jonathan Edwards and
               Tomas Petricek},
  title     = {Technical Dimensions of Programming Systems},
  journal   = {The Art, Science, and Engineering of Programming},
  volume    = {7},
  number    = {3},
  year      = {2023},
  issn =  {2473-7321},
  doi       = {10.22152/PROGRAMMING-JOURNAL.ORG/2023/7/13},
  timestamp = {Fri, 21 Apr 2023 15:49:56 +0200},
}

@article{Teitelbaum81,
author = {Teitelbaum, Tim and Reps, Thomas},
title = {The Cornell Program Synthesizer: A Syntax-Directed Programming Environment},
year = {1981},
issue_date = {Sept. 1981},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {24},
number = {9},
issn = {0001-0782},
doi = {10.1145/358746.358755},
abstract = {Programs are not text; they are hierarchical compositions of computational structures
and should be edited, executed, and debugged in an environment that consistently acknowledges
and reinforces this viewpoint. The Cornell Program Synthesizer demands a structural
perspective at all stages of program development. Its separate features are unified
by a common foundation: a grammar for the programming language. Its full-screen derivation-tree
editor and syntax-directed diagnostic interpreter combine to make the Synthesizer
a powerful and responsive interactive programming tool.},
journal = {Communications ACM},
month = sep,
pages = {563--573},
numpages = {11},
keywords = {programming environment, source language debugger, syntax-directed editor, template, diagnostic interpreter, program development system}
}

@article{Tranquility,
author = {Vandewoude, Yves and Ebraert, Peter and Berbers, Yolande and D'Hondt, Theo},
title = {Tranquility: A Low Disruptive Alternative to Quiescence for Ensuring Safe Dynamic Updates},
year = {2007},
issue_date = {December 2007},
publisher = {IEEE Press},
volume = {33},
number = {12},
issn = {0098-5589},
doi = {10.1109/TSE.2007.70733},
abstract = {This paper revisits a problem that was identified by Kramer and Magee: placing a system in a consistent state before and after runtime changes. We show that their notion of quiescence as a necessary and sufficient condition for safe runtime changes is too strict and results in a significant disruption in the application being updated. In this paper, we introduce a weaker condition: tranquility. We show that tranquility is easier to obtain and less disruptive for the running application but still a sufficient condition to ensure application consistency. We present an implementation of our approach on a component middleware platform and experimentally verify the validity and practical applicability of our approach using data retrieved from a case study.},
journal = {IEEE Transactions on Software Engineering},
month = dec,
pages = {856--868},
numpages = {13},
keywords = {Distributed objects, components, Application-aware adaptation, containers, Componentware}
}

@article{Trenouth91,
  author   = {Trenouth, J.},
  title    = {{A Survey of Exploratory Software Development}},
  journal  = {The Computer Journal},
  volume   = {34},
  number   = {2},
  pages    = {153-163},
  year     = {1991},
  month    = {01},
  abstract = {{Exploratory software development is an important style of software development that has a markedly different flavour from conventional software engineering methodologies. Originally used in artificial intelligence programming, it has much in common with both rapid prototyping and software maintenance. This paper surveys the area, by examining the methodology, technology, and related issues.}},
  issn     = {0010-4620},
  doi      = {10.1093/comjnl/34.2.153},
  eprint   = {https://academic.oup.com/comjnl/article-pdf/34/2/153/1400604/340153.pdf}
}

@inproceedings{vanRozen15,
  author    = {van Rozen, Riemer
               and van der Storm, Tijs},
  editor    = {Kolovos, Dimitris
               and Wimmer, Manuel},
  title     = {Origin Tracking {\$}{\$}+{\$}{\$}Text Differencing {\$}{\$}={\$}{\$}Textual Model Differencing},
  booktitle = {Theory and Practice of Model Transformations},
  year      = {2015},
  publisher = {Springer International Publishing},
  address   = {Cham},
  pages     = {18--33},
  abstract  = {In textual modeling, models are created through an intermediate parsing step which maps textual representations to abstract model structures. Therefore, the identify of elements is not stable across different versions of the same model. Existing model differencing algorithms, therefore, cannot be applied directly because they need to identify model elements across versions. In this paper we present Textual Model Diff (tmdiff), a technique to support model differencing for textual languages. tmdiff requires origin tracking during text-to-model mapping to trace model elements back to the symbolic names that define them in the textual representation. Based on textual alignment of those names, tmdiff can then determine which elements are the same across revisions, and which are added or removed. As a result, tmdiff brings the benefits of model differencing to textual languages.},
  isbn      = {978-3-319-21155-8}
}

@article{vanRozen19,
  author     = {Rozen, Riemer and Storm, Tijs},
  title      = {Toward live domain-specific languages},
  year       = {2019},
  issue_date = {February  2019},
  publisher  = {Springer-Verlag},
  address    = {Berlin, Heidelberg},
  volume     = {18},
  number     = {1},
  issn       = {1619-1366},
  doi        = {10.1007/s10270-017-0608-7},
  journal    = {Software and Systems Modeling},
  month      = feb,
  pages      = {195–212},
  numpages   = {18},
  keywords   = {Text differencing, Models at run time, Model patching, Live programming, Domain-specific languages, Adapting models}
}

@inproceedings{vanRozen23,
  author    = {van Rozen, Riemer},
  title     = {Cascade: A Meta-language for Change, Cause and Effect},
  year      = {2023},
  isbn      = {9798400703966},
  publisher = {Association for Computing Machinery},
  doi       = {10.1145/3623476.3623515},
  abstract  = {Live programming brings code to life with immediate and continuous feedback. To enjoy its benefits, programmers need powerful languages and live programming environments for understanding the effects of code modifications on running programs. Unfortunately, the enabling technology that powers these languages, is missing. Change, a crucial enabler for explorative coding, omniscient debugging and version control, is a potential solution.
               We aim to deliver generic solutions for creating these languages, in particular Domain-Specific Languages (DSLs). We present Cascade, a meta-language for expressing DSLs with interface- and feedback-mechanisms that drive live programming. We demonstrate run-time migrations, ripple effects and live desugaring of three existing DSLs. Our results show that an explicit representation of change is instrumental for how these languages are built, and that cause-and-effect relationships are vital for delivering precise feedback.},
  booktitle = {Proceedings of the 16th ACM SIGPLAN International Conference on Software Language Engineering},
  pages     = {149–162},
  numpages  = {14},
  keywords  = {bidirectional transformations, domain-specific languages, live programming, metamodels, model migration},
  location  = {Cascais, Portugal},
  series    = {SLE 2023}
}

@inproceedings{vermolen11,
  author    = {Vermolen, Sander Dani\"{e}l and Wachsmuth, Guido and Visser, Eelco},
  title     = {Generating database migrations for evolving web applications},
  year      = {2011},
  isbn      = {9781450306898},
  publisher = {Association for Computing Machinery},
  doi       = {10.1145/2047862.2047876},
  abstract  = {WebDSL is a domain-specific language for the implementation of dynamic web applications with a rich data model. It provides developers with object-oriented data modeling concepts but abstracts over implementation details for persisting application data in relational databases. When the underlying data model of an application evolves, persisted application data has to be migrated. While implementing migration at the database level breaks the abstractions provided by WebDSL, an implementation at the data model level requires to intermingle migration with application code. In this paper, we present a domain-specific language for the coupled evolution of data models and application data. It allows to specify data model evolution as a separate concern at the data model level and can be compiled to migration code at the database level. Its linguistic integration with WebDSL enables static checks for evolution validity and correctness.},
  booktitle = {Proceedings of the 10th ACM International Conference on Generative Programming and Component Engineering},
  pages     = {83–92},
  numpages  = {10},
  keywords  = {data migration, domain specific language, evolution, web application},
  location  = {Portland, Oregon, USA},
  series    = {GPCE '11}
}

@inproceedings{wang19,
  author    = {Wang, Yuepeng and Dong, James and Shah, Rushi and Dillig, Isil},
  title     = {Synthesizing database programs for schema refactoring},
  year      = {2019},
  isbn      = {9781450367127},
  publisher = {Association for Computing Machinery},
  doi       = {10.1145/3314221.3314588},
  abstract  = {Many programs that interact with a database need to undergo schema refactoring several times during their life cycle. Since this process typically requires making significant changes to the program's implementation, schema refactoring is often non-trivial and error-prone. Motivated by this problem, we propose a new technique for automatically synthesizing a new version of a database program given its original version and the source and target schemas. Our method does not require manual user guidance and ensures that the synthesized program is equivalent to the original one. Furthermore, our method is quite efficient and can synthesize new versions of database programs (containing up to 263 functions) that are extracted from real-world web applications with an average synthesis time of 69.4 seconds.},
  booktitle = {Proceedings of the 40th ACM SIGPLAN Conference on Programming Language Design and Implementation},
  pages     = {286–300},
  numpages  = {15},
  keywords  = {Relational Databases, Program Synthesis, Program Sketching},
  location  = {Phoenix, AZ, USA},
  series    = {PLDI 2019}
}

@article{wang20,
  author     = {Wang, Yuepeng and Shah, Rushi and Criswell, Abby and Pan, Rong and Dillig, Isil},
  title      = {Data migration using datalog program synthesis},
  year       = {2020},
  issue_date = {March 2020},
  publisher  = {VLDB Endowment},
  volume     = {13},
  number     = {7},
  issn       = {2150-8097},
  doi        = {10.14778/3384345.3384350},
  abstract   = {This paper presents a new technique for migrating data between different schemas. Our method expresses the schema mapping as a Datalog program and automatically synthesizes a Datalog program from simple input-output examples to perform data migration. This approach can transform data between different types of schemas (e.g., relational-tograph, document-to-relational) and performs synthesis efficiently by leveraging the semantics of Datalog. We implement the proposed technique as a tool called Dynamite and show its effectiveness by evaluating Dynamite on 28 realistic data migration scenarios.},
  journal    = {Proceedings VLDB Endowment},
  month      = mar,
  pages      = {1006–1019},
  numpages   = {14}
}

@ARTICLE{AIassistants,
  author={Petricek, Tomas and Burg, Gerrit J. J. van den and Nazábal, Alfredo and Ceritli, Taha and Jiménez-Ruiz, Ernesto and Williams, Christopher K. I.},
  journal={IEEE Transactions on Knowledge and Data Engineering},
  title={AI Assistants: A Framework for Semi-Automated Data Wrangling},
  year={2023},
  volume={35},
  number={9},
  pages={9295-9306},
  doi={10.1109/TKDE.2022.3222538}}

@article{challenge-problems,
  title     = {Schema Evolution in Interactive Programming Systems},
  volume    = {9},
  issn      = {2473-7321},
  url       = {http://dx.doi.org/10.22152/programming-journal.org/2025/9/2},
  doi       = {10.22152/programming-journal.org/2025/9/2},
  number    = {1},
  journal   = {The Art, Science, and Engineering of Programming},
  publisher = {Aspect-Oriented Software Association (AOSA)},
  author    = {Edwards, Jonathan and Petricek, Tomas and van der Storm, Tijs and Litt, Geoffrey},
  year      = {2024},
  month     = oct
}


@inproceedings{denicek,
  author    = {Petricek, Tomas and Edwards, Jonathan},
  title     = {Denicek: Computational Substrate for Document-Oriented End-User Programming},
  year      = {2025},
  isbn      = {9798400720376},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3746059.3747646},
  doi       = {10.1145/3746059.3747646},
  abstract  = {User-centric programming research gave rise to a variety of compelling programming experiences, including collaborative source code editing, programming by demonstration, incremental recomputation, schema change control, end-user debugging and concrete programming. Those experiences advance the state of the art of end-user programming, but they are hard to implement on the basis of established programming languages and system. We contribute Denicek, a computational substrate that simplifies the implementation of the above programming experiences. Denicek represents a program as a series of edits that construct and transform a document consisting of data and formulas. Denicek provides three operations on edit histories: edit application, merging of histories and conflict resolution. Many programming experiences can be easily implemented by composing these three operations. We present the architecture of Denicek, discuss key design considerations and elaborate the implementation of a variety of programming experiences. To evaluate the proposed substrate, we use Denicek to develop an innovative interactive data science notebook system. The case study shows that the Denicek computational substrate provides a suitable basis for the design of rich, interactive end-user programming systems.},
  booktitle = {Proceedings of the 38th Annual ACM Symposium on User Interface Software and Technology},
  articleno = {32},
  numpages  = {19},
  keywords  = {Programming Systems, End-User Programming},
  location  = {},
  series    = {UIST '25}
}

 @inproceedings{sculpin,
  author    = {Horowitz, Joshua and Hayatpur, Devamardeep and Xia, Haijun and Heer, Jeffrey},
  title     = {Sculpin: Direct-Manipulation Transformation of JSON},
  year      = {2025},
  isbn      = {9798400720376},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3746059.3747651},
  doi       = {10.1145/3746059.3747651},
  abstract  = {Many end-user programming tasks require programmatically processing JSON, wrangling it from one format to another or building interactive applications atop it. But end-users are impeded by the indirectness and steep learning curve of textual code. We present Sculpin, a direct-manipulation environment supporting a broad range of JSON-transformation tasks. A user of Sculpin transforms JSON data step by step, recording a program in the process. Sculpin makes three design commitments to ensure directness and versatility: (1) steps are small and precise, not inferred; (2) steps are general-purpose and open to re-appropriation; (3) steps operate on JSON itself, rather than on a limited intermediate representation. To support these commitments, Sculpin introduces a mechanism of sculptable selections: the user can direct their action by guiding a selection on top of the data through small steps like generalization and hierarchical navigation. Sculpin also extends JSON with embedded interface elements like form inputs and buttons, allowing applications to be sculpted incrementally from source data. We demonstrate the breadth and directness of Sculpin in use-cases ranging from wrangling data to building applications. We evaluate Sculpin through a heuristic analysis, situating it in a broad space of programming systems and surfacing limitations such as difficulties editing preexisting programs.},
  booktitle = {Proceedings of the 38th Annual ACM Symposium on User Interface Software and Technology},
  articleno = {34},
  numpages  = {15},
  keywords  = {end-user programming, programming by demonstration, direct manipulation},
  location  = {},
  series    = {UIST '25}
}

@misc{perera2021,
  title         = {Linked visualisations via Galois dependencies},
  author        = {Roly Perera and Minh Nguyen and Tomas Petricek and Meng Wang},
  year          = {2021},
  eprint        = {2109.00445},
  archiveprefix = {arXiv},
  primaryclass  = {cs.PL},
  url           = {https://arxiv.org/abs/2109.00445}
}

@inproceedings{church2014case,
  title     = {A case of computational thinking: The subtle effect of hidden dependencies on the user experience of version control.},
  author    = {Church, Luke and S{\"o}derberg, Emma and Elango, Elayabharath},
  booktitle = {PPIG},
  pages     = {16},
  year      = {2014}
}

@misc{xkcd1597,
  title   = {Git},
  url     = {https://xkcd.com/1597/},
  journal = {xkcd},
  author  = {Munroe, Randall},
    note   = {[Online; accessed 29-August-2025]}
}
@misc{philomatics-git,
  title   = {Never use git cherry-pick},
  url     = {https://www.youtube.com/watch?v=WPCxtFkLa7g},
  author  = {von Franqué, Alexander},
    note   = {[Online; accessed 29-August-2025]}
}
@article{myers86,
  author     = {Myers, Eugene W.},
  title      = {AnO(ND) difference algorithm and its variations},
  year       = {1986},
  issue_date = {Nov 1986},
  publisher  = {Springer-Verlag},
  address    = {Berlin, Heidelberg},
  volume     = {1},
  number     = {1–4},
  issn       = {0178-4617},
  url        = {https://doi.org/10.1007/BF01840446},
  doi        = {10.1007/BF01840446},
  abstract   = {The problems of finding a longest common subsequence of two sequencesA andB and a shortest edit script for transformingA intoB have long been known to be dual problems. In this paper, they are shown to be equivalent to finding a shortest/longest path in an edit graph. Using this perspective, a simpleO(ND) time and space algorithm is developed whereN is the sum of the lengths ofA andB andD is the size of the minimum edit script forA andB. The algorithm performs well when differences are small (sequences are similar) and is consequently fast in typical applications. The algorithm is shown to haveO(N+D2) expected-time performance under a basic stochastic model. A refinement of the algorithm requires onlyO(N) space, and the use of suffix trees leads to anO(N logN+D2) time variation.},
  journal    = {Algorithmica},
  month      = nov,
  pages      = {251–266},
  numpages   = {16},
  keywords   = {Longest common subsequence, Shortest edit script, Edit graph, File comparison}
}

@article{alikhanifard24,
  author     = {Alikhanifard, Pouria and Tsantalis, Nikolaos},
  title      = {A Novel Refactoring and Semantic Aware Abstract Syntax Tree Differencing Tool and a Benchmark for Evaluating the Accuracy of Diff Tools},
  year       = {2025},
  issue_date = {February 2025},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {34},
  number     = {2},
  issn       = {1049-331X},
  url        = {https://doi.org/10.1145/3696002},
  doi        = {10.1145/3696002},
  abstract   = {Software undergoes constant changes to support new requirements, address bugs, enhance performance, and ensure maintainability. Thus, developers spend a great portion of their workday trying to understand and review the code changes of their teammates. Abstract Syntax Tree (AST) diff tools were developed to overcome the limitations of line-based diff tools, which are used by the majority of developers. Despite the notable improvements brought by AST diff tools in understanding complex changes, they still suffer from serious limitations, such as (1) lacking multi-mapping support, (2) matching semantically incompatible AST nodes, (3) ignoring language clues to guide the matching process, (4) lacking refactoring awareness, and (5) lacking commit-level diff support. We propose a novel AST diff tool based on RefactoringMiner that resolves all aforementioned limitations. First, we improved RefactoringMiner to increase its statement mapping accuracy, and then we developed an algorithm that generates AST diff for a given commit or pull request based on the refactoring instances and pairs of matched program element declarations provided by RefactoringMiner. To evaluate the accuracy of our tool and compare it with the state-of-the-art tools, we created the first benchmark of AST node mappings, including 800 bug-fixing commits and 188 refactoring commits. Our evaluation showed that our tool achieved a considerably higher precision and recall, especially for refactoring commits, with an execution time that is comparable with that of the faster tools.},
  journal    = {ACM Trans. Softw. Eng. Methodol.},
  month      = jan,
  articleno  = {40},
  numpages   = {63},
  keywords   = {Source code differencing, Abstract Syntax Trees, Benchmark}
}
@book{kim2022devops,
  title     = {The DevOps Handbook, Second Edition: How to Create World-Class Agility, Reliability, \& Security in Technology Organizations},
  author    = {Kim, Gene and Humble, Jez and Debois, Patrick},
  year      = {2022},
  publisher = {IT Revolution},
  isbn      = {978-1942788003}
}
@inproceedings{warth11,
  author    = {Warth, Alessandro and Ohshima, Yoshiki and Kaehler, Ted and Kay, Alan},
  title     = {Worlds: controlling the scope of side effects},
  year      = {2011},
  isbn      = {9783642226540},
  publisher = {Springer-Verlag},
  address   = {Berlin, Heidelberg},
  abstract  = {The state of an imperative program--e.g., the values stored in global and local variables, arrays, and objects' instance variables--changes as its statements are executed. These changes, or side effects, are visible globally: when one part of the program modifies an object, every other part that holds a reference to the same object (either directly or indirectly) is also affected. This paper introduces worlds, a language construct that reifies the notion of program state and enables programmers to control the scope of side effects. We investigate this idea by extending both JavaScript and Squeak Smalltalk with support for worlds, provide examples of some of the interesting idioms this construct makes possible, and formalize the semantics of property/field lookup in the presence of worlds. We also describe an efficient implementation strategy (used in our Squeak-based prototype), and illustrate the practical benefits of worlds with two case studies.},
  booktitle = {Proceedings of the 25th European Conference on Object-Oriented Programming},
  pages     = {179–203},
  numpages  = {25},
  location  = {Lancaster, UK},
  series    = {ECOOP'11}
}
@techreport{Sundmark02,
  author      = {Daniel Sundmark},
  title       = {Replay Debugging of Embedded Real-Time Systems: A State of the Art Report},
  year        = {2002},
  institution = {M\"alardalen University, Department of Computer Science and Engineering},
  number      = {Technical Report 63},
  month       = {September},
  url         = {http://www.es.mdu.se/pdf_publications/646.pdf}
}
@misc{ocallahan16,
  title         = {Lightweight User-Space Record And Replay},
  author        = {Robert O'Callahan and Chris Jones and Nathan Froyd and Kyle Huey and Albert Noll and Nimrod Partush},
  year          = {2016},
  eprint        = {1610.02144},
  archiveprefix = {arXiv},
  primaryclass  = {cs.PL},
  url           = {https://arxiv.org/abs/1610.02144}
}
@misc{difftastic,
  title   = {difftastic},
  url     = {https://difftastic.wilfred.me.uk},
  author  = {Wilfred Hughes},
  note    = {[Online; accessed 29-August-2025]}
}

@inproceedings{edit-lenses,
  author    = {Hofmann, Martin and Pierce, Benjamin and Wagner, Daniel},
  title     = {Edit lenses},
  year      = {2012},
  isbn      = {9781450310833},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/2103656.2103715},
  doi       = {10.1145/2103656.2103715},
  abstract  = {A lens is a bidirectional transformation between a pair of connected data structures, capable of translating an edit on one structure into an appropriate edit on the other. Many varieties of lenses have been studied, but none, to date, has offered a satisfactory treatment of how edits are represented. Many foundational accounts only consider edits of the form "overwrite the whole structure," leading to poor behavior in many situations by failing to track the associations between corresponding parts of the structures when elements are inserted and deleted in ordered lists, for example. Other theories of lenses do maintain these associations, either by annotating the structures themselves with change information or using auxiliary data structures, but every extant theory assumes that the entire original source structure is part of the information passed to the lens.We offer a general theory of edit lenses, which work with descriptions of changes to structures, rather than with the structures themselves. We identify a simple notion of "editable structure"--a set of states plus a monoid of edits with a partial monoid action on the states--and construct a semantic space of lenses between such structures, with natural laws governing their behavior. We show how a range of constructions from earlier papers on "state-based" lenses can be carried out in this space, including composition, products, sums, list operations, etc. Further, we show how to construct edit lenses for arbitrary containers in the sense of Abbott, Altenkirch, and Ghani. Finally, we show that edit lenses refine a well-known formulation of state-based lenses, in the sense that every state-based lens gives rise to an edit lens over structures with a simple overwrite-only edit language, and conversely every edit lens on such structures gives rise to a state-based lens.},
  booktitle = {Proceedings of the 39th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
  pages     = {495–508},
  numpages  = {14},
  keywords  = {algebra, bidirectional programming, edit, lens, symmetric},
  location  = {Philadelphia, PA, USA},
  series    = {POPL '12}
}

@inbook{Chen1996,
  author    = {Chen, Jian
               and Huang, Qiming},
  editor    = {Cheung, To-yat
               and Fong, Joseph
               and Siu, Brian},
  title     = {Eliminating the Impedance Mismatch Between Relational and Object-Oriented Systems},
  booktitle = {Database Reengineering and Interoperability},
  year      = {1996},
  publisher = {Springer US},
  address   = {Boston, MA},
  pages     = {89--102},
  abstract  = {Relational database management systems (RDMSs) and their extensions have been widely used in industry for many years. Although there has been much research done for developing the object-oriented database systems recently, it is believed that the relational database systems will at least be used in industry for many years8. On the other hand, object-oriented programming languages become more acceptable by software developers. It is therefore important to develop appropriate facilities in an object-oriented programming language for accessing and programming the relational and the extended relational database systems.},
  isbn      = {978-1-4615-1803-7},
  doi       = {10.1007/978-1-4615-1803-7_8},
  url       = {https://doi.org/10.1007/978-1-4615-1803-7_8}
}

@article{Dayal82,
  author     = {Dayal, Umeshwar and Bernstein, Philip A.},
  title      = {On the correct translation of update operations on relational views},
  year       = {1982},
  issue_date = {Sept. 1982},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {7},
  number     = {3},
  issn       = {0362-5915},
  url        = {https://doi.org/10.1145/319732.319740},
  doi        = {10.1145/319732.319740},
  abstract   = {Most relational database systems provide a facility for supporting user views. Permitting this level of abstraction has the danger, however, that update requests issued by a user within the context of his view may not translate correctly into equivalent updates on the underlying database. The purpose of this paper is to formalize the notion of update translation and derive conditions under which translation procedures will produce correct translations of view updates.},
  journal    = {ACM Trans. Database Syst.},
  month      = sep,
  pages      = {381–416},
  numpages   = {36},
  keywords   = {user views, update translation, schema mapping, relational databases, external schemata}
}

@misc{edwards21,
  title         = {Typed Image-based Programming with Structure Editing},
  author        = {Jonathan Edwards and Tomas Petricek},
  year          = {2021},
  eprint        = {2110.08993},
  archiveprefix = {arXiv},
  primaryclass  = {cs.PL},
  url           = {https://arxiv.org/abs/2110.08993}
}

@inproceedings{edwards22,
  author    = {Edwards, Jonathan and Petricek, Tomas},
  title     = {Interaction vs. Abstraction: Managed Copy and Paste},
  year      = {2022},
  isbn      = {9781450399104},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3563836.3568723},
  doi       = {10.1145/3563836.3568723},
  booktitle = {Proceedings of the 1st ACM SIGPLAN International Workshop on Programming Abstractions and Interactive Notations, Tools, and Environments},
  pages     = {11–19},
  numpages  = {9},
  keywords  = {version control, structure editing, copy \& paste, code clones},
  location  = {Auckland, New Zealand},
  series    = {PAINT 2022}
}

@book{cypher93-pbd,
  title={Watch what I do: {P}rogramming by demonstration},
  author={Cypher, Allen and Halbert, Daniel Conrad},
  year={1993},
  publisher={MIT press}
}

@article{gupta93,
  author     = {Gupta, Ashish and Mumick, Inderpal Singh and Subrahmanian, V. S.},
  title      = {Maintaining views incrementally},
  year       = {1993},
  issue_date = {June 1, 1993},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {22},
  number     = {2},
  issn       = {0163-5808},
  url        = {https://doi.org/10.1145/170036.170066},
  doi        = {10.1145/170036.170066},
  journal    = {SIGMOD Rec.},
  month      = jun,
  pages      = {157–166},
  numpages   = {10}
}

@article{curino10,
  author     = {Curino, Carlo A. and Moon, Hyun Jin and Deutsch, Alin and Zaniolo, Carlo},
  title      = {Update rewriting and integrity constraint maintenance in a schema evolution support system: PRISM++},
  year       = {2010},
  issue_date = {November 2010},
  publisher  = {VLDB Endowment},
  volume     = {4},
  number     = {2},
  issn       = {2150-8097},
  url        = {https://doi.org/10.14778/1921071.1921078},
  doi        = {10.14778/1921071.1921078},
  abstract   = {Supporting legacy applications when the database schema evolves represents a long-standing challenge of practical and theoretical importance. Recent work has produced algorithms and systems that automate the process of data migration and query adaptation; however, the problems of evolving integrity constraints and supporting legacy updates under schema and integrity constraints evolution are significantly more difficult and have thus far remained unsolved. In this paper, we address this issue by introducing a formal evolution model for the database schema structure and its integrity constraints, and use it to derive update mapping techniques akin to the rewriting techniques used for queries. Thus, we (i) propose a new set of Integrity Constraints Modification Operators (ICMOs), (ii) characterize the impact on integrity constraints of structural schema changes, (iii) devise representations that enable the rewriting of updates, and (iv) develop a unified approach for query and update rewriting under constraints. We then describe the implementation of these techniques provided by our PRISM++ system. The effectiveness of PRISM++ and its enabling technology has been verified on a testbed containing evolution histories of several scientific databases and web information systems, including the Genetic DB Ensembl (410+ schema versions in 9 years), and Wikipedia (240+ schema versions in 6 years).},
  journal    = {Proc. VLDB Endow.},
  month      = nov,
  pages      = {117–128},
  numpages   = {12}
}
@misc{miller-columns,
  author       = {{Wikipedia contributors}},
  title        = {Miller columns --- {Wikipedia}{,} The Free Encyclopedia},
  year         = {2025},
  howpublished = {\url{https://en.wikipedia.org/w/index.php?title=Miller_columns&oldid=1305075621}},
  note         = {[Online; accessed 12-September-2025]}
}
@phdthesis{bakke:phdthesis,
  sortname = {Bakke2016-09},
  author   = {Eirik Bakke},
  title    = {Expressive Query Construction through Direct Manipulation of Nested Relational Results},
  school   = {Massachusetts Institute of Technology},
  year     = {2016},
  month    = {9},
  note     = {Available at \url{https://dspace.mit.edu/handle/1721.1/107280}}
}
@online{ultorg,
  author  = {Eirik Bakke},
  title   = {Ultorg},
  year    = 2025,
  url     = {https://www.ultorg.com},
  urldate = {2025-09-14}
}
@inproceedings{olsen07,
  author    = {Olsen, Dan R.},
  title     = {Evaluating user interface systems research},
  year      = {2007},
  isbn      = {9781595936790},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/1294211.1294256},
  doi       = {10.1145/1294211.1294256},
  abstract  = {The development of user interface systems has languished with the stability of desktop computing. Future systems, however, that are off-the-desktop, nomadic or physical in nature will involve new devices and new software systems for creating interactive applications. Simple usability testing is not adequate for evaluating complex systems. The problems with evaluating systems work are explored and a set of criteria for evaluating new UI systems work is presented.},
  booktitle = {Proceedings of the 20th Annual ACM Symposium on User Interface Software and Technology},
  pages     = {251–258},
  numpages  = {8},
  keywords  = {user interface systems evaluation},
  location  = {Newport, Rhode Island, USA},
  series    = {UIST '07}
}

@inproceedings{sun00,
  author    = {Sun, Chengzheng},
  title     = {Undo any operation at any time in group editors},
  year      = {2000},
  isbn      = {1581132220},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/358916.358990},
  doi       = {10.1145/358916.358990},
  abstract  = {The ability to undo operations is an indispensable feature of real-time group editors, but supporting group undo is a difficult problem.  None of the existing solutions for group undo is able to support undoing any operation at any time with guaranteed success. In this paper, we contribute a novel group undo solution with such a capability. The basic idea is to interpret an undo command as a concurrent inverse operation by means of operational transformation, so that an operation is always undoable regardless of its undo context. By separating undo policy from undo mechanism, multiple undo modes, such as single-step undo, chronological undo, and selective undo, can be supported in the same collaborative editing session.  In addition, solutions to known undo puzzles are also   provided. A web-based group text editor using the proposed undo solution has been implemented and is accessible at: http://reduce.qpsf.edu.au.},
  booktitle = {Proceedings of the 2000 ACM Conference on Computer Supported Cooperative Work},
  pages     = {191–200},
  numpages  = {10},
  keywords  = {operational transformation, groupware, group undo, group editors, distributed computing},
  location  = {Philadelphia, Pennsylvania, USA},
  series    = {CSCW '00}
}


@techreport{weiss08,
  title       = {{A Flexible Undo Framework for Collaborative Editing}},
  author      = {Weiss, St{\'e}phane and Urso, Pascal and Molli, Pascal},
  url         = {https://inria.hal.science/inria-00275754},
  type        = {Research Report},
  number      = {RR-6516},
  institution = {{INRIA}},
  year        = {2008},
  pdf         = {https://inria.hal.science/inria-00275754v2/file/RR-6516.pdf},
  hal_id      = {inria-00275754},
  hal_version = {v2}
}
@techreport{martin10,
  title       = {{Scalable XML Collaborative Editing with Undo}},
  author      = {Martin, St{\'e}phane and Urso, Pascal and Weiss, St{\'e}phane},
  url         = {https://inria.hal.science/inria-00508436},
  type        = {Research Report},
  number      = {RR-7362},
  pages       = {23},
  institution = {{INRIA}},
  year        = {2010},
  month       = Aug,
  pdf         = {https://inria.hal.science/inria-00508436v1/file/RR-7362.pdf},
  hal_id      = {inria-00508436},
  hal_version = {v1}
}

@article{abowd92,
    author = {Abowd, Gregory D. and Dix, Alan J.},
    title = {Giving undo attention},
    journal = {Interacting with Computers},
    volume = {4},
    number = {3},
    pages = {317-342},
    year = {1992},
    month = {12},
    abstract = {The problems associated with the provision of an undo support facility in the context of a synchronous shared or group editor are investigated. Previous work on the development of formal models of ‘undo’ has been restricted to single user systems and has focused on the functionality of undo, as opposed to discussing the support that users require from any error recovery facility. Motivated by new issues that arise in the context of computer supported co-operative work, the authors aim to integrate formal modelling of undo with an analysis of how users understand undo facilities. Together, these combined perspectives of the system and user lead to concrete design advice for implementing an undo facility. The special issues that arise in the context of shared undo also shed light on the emphasis that should be placed on single user undo. In particular, the authors regard undo not as a system command to be implemented, but as a user intention to be supported by the system.},
    issn = {0953-5438},
    doi = {10.1016/0953-5438(92)90021-7},
    url = {https://doi.org/10.1016/0953-5438(92)90021-7},
    eprint = {https://academic.oup.com/iwc/article-pdf/4/3/317/2175174/iwc4-0317.pdf},
}

@article{berlage94,
  author     = {Berlage, Thomas},
  title      = {A selective undo mechanism for graphical user interfaces based on command objects},
  year       = {1994},
  issue_date = {Sept. 1994},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {1},
  number     = {3},
  issn       = {1073-0516},
  url        = {https://doi.org/10.1145/196699.196721},
  doi        = {10.1145/196699.196721},
  abstract   = {It is important to provide a recovery operation for applications with a graphical user interface. A restricted linear undo mechanism can conveniently be implemented using object-oriented techniques. Although linear undo provides an arbitrarily long history, it is not possible to undo isolated commands from the history without undoing all following commands. Various undo models have been proposed to overcome this limitation, but they all ignore the problem that in graphical user interfaces a previous user action might not have a sensible interpretation in another state.Selective undo introduced here can undo isolated commands by copying them into the current state “if that is meaningful.” Furthermore, the semantics of selective  undo are argued to be more natural for the user, because the mechanism only looks at the command to undo and the current state and does not depend on the history in between. The user interface for selective undo can also be implemented generically. Such a generic implementation is able to provide a consistent recovery mechanism in arbitrary applications.},
  journal    = {ACM Trans. Comput.-Hum. Interact.},
  month      = sep,
  pages      = {269–294},
  numpages   = {26},
  keywords   = {command objects, groupware, undo}
}


@online{braid,
  author  = {Michael Toomim},
  title   = {Collapsing Time Machines},
  year    = 2025,
  url     = {https://braid.org/time-machines},
  urldate = {2025-09-14}
}
@online{patchwork,
  author  = {Geoffrey Litt and
Paul Sonnentag and
Max Schöning and
Adam Wiggins and
Peter van Hardenberg and
Orion Henry},
  title   = {Patchwork},
  year    = 2024,
  url     = {https://www.inkandswitch.com/patchwork/notebook/},
  urldate = {2025-09-14}
}

@online{ceda,
  author  = {David Barrett-Lennard},
  title   = {Introducing CEDA},
  year    = 2010,
  url     = {https://cedanet.com.au/ceda/papers/Introducing%20CEDA.pdf},
  urldate = {2025-09-14}
}

@online{ceda-ot,
  author  = {David Barrett-Lennard},
  title   = {Operational Transformation},
  year    = 2010,
  url     = {https://cedanet.com.au/ceda/ot/},
  urldate = {2025-09-14}
}

@article{zloof77,
  author   = {Zloof, M. M.},
  journal  = {IBM Systems Journal},
  title    = {Query-by-Example: A data base language},
  year     = {1977},
  volume   = {16},
  number   = {4},
  pages    = {324-343},
  keywords = {},
  doi      = {10.1147/sj.164.0324}
}

@online{hackage-optics,
  author  = {Adam Gundry, Andres Löh, Andrzej Rybczak, Oleg Grenrus},
  title   = {Optics as an Abstract Interface},
  year    = 2024,
  url     = {https://hackage.haskell.org/package/optics},
  urldate = {2025-09-14}
}

@online{hackage-lens,
  author  = {Gabriella Gonzalez},
  title   = {Lens Tutorial},
  year    = 2024,
  url     = {https://hackage.haskell.org/package/lens-tutorial},
  urldate = {2025-09-14}
}

@inproceedings{czarnecki2009bidirectional,
  author    = {Czarnecki, Krzysztof
               and Foster, J. Nathan
               and Hu, Zhenjiang
               and L{\"a}mmel, Ralf
               and Sch{\"u}rr, Andy
               and Terwilliger, James F.},
  editor    = {Paige, Richard F.},
  title     = {Bidirectional Transformations: A Cross-Discipline Perspective},
  booktitle = {Theory and Practice of Model Transformations},
  year      = {2009},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {260--283},
  abstract  = {The GRACE International Meeting on Bidirectional Transformations was held in December 2008 near Tokyo, Japan. The meeting brought together researchers and practitioners from a variety of sub-disciplines of computer science to share research efforts and help create a new community. In this report, we survey the state of the art and summarize the technical presentations delivered at the meeting. We also describe some insights gathered from our discussions and introduce a new effort to establish a benchmark for bidirectional transformations.},
  isbn      = {978-3-642-02408-5}
}

@book{hu2024bidirectional,
  editor    = {Hu, Zhenjiang and Onizuka, Makoto and Yoshikawa, Masatoshi},
  title     = {Bidirectional Collaborative Data Management: Collaboration Frameworks for Decentralized Systems},
  publisher = {Springer},
  year      = {2024},
  isbn      = {978-981-97-6428-0}
}

@inproceedings{ignat-synql,
  title       = {{Synql: A CRDT-Based Approach for~Replicated Relational Databases with~Integrity Constraints}},
  author      = {Ignat, Claudia-Lavinia and Elvinger, Victorien and Ba, Habibatou},
  url         = {https://inria.hal.science/hal-04969158},
  booktitle   = {{Lecture Notes in Computer Science}},
  address     = {Groningen, Netherlands},
  editor      = {Rolando Martins},
  publisher   = {{Springer Nature Switzerland}},
  series      = {Distributed Applications and Interoperable Systems},
  volume      = {LNCS-14677},
  pages       = {18-35},
  year        = {2024},
  month       = Jun,
  doi         = {10.1007/978-3-031-62638-8\_2},
  pdf         = {https://inria.hal.science/hal-04969158v4/file/DAIS2024.pdf},
  hal_id      = {hal-04969158},
  hal_version = {v4}
}

@article{exelmans25,
  abstract      = {Live modeling is the ability to edit an executable model at run-time, and to subsequently continue the execution instead of having to restart it. Few modeling frameworks support this feature. Much of the research concerning live modeling attempts to bring ``liveness''to existing modeling languages and environments, which is a complex, and often ad hoc endeavor. We instead argue to build modeling environments on an operation-based versioning foundation, to not only record edit operations, but also execution steps on an explicit run-time model. This reduces the complexity of patching the run-time state with edit operations to a simple merge-operation, while getting powerful features such as collaborative editing and debugging ``for free.''},
  author        = {Exelmans, Joeri and Teodorov, Ciprian and Vangheluwe, Hans},
  date          = {2025/06/01},
  date-added    = {2025-09-26 13:33:26 -0400},
  date-modified = {2025-09-26 13:33:26 -0400},
  doi           = {10.1007/s10270-024-01212-x},
  id            = {Exelmans2025},
  isbn          = {1619-1374},
  journal       = {Software and Systems Modeling},
  number        = {3},
  pages         = {721--739},
  title         = {Operation-based versioning as a foundation for live executable models},
  url           = {https://doi.org/10.1007/s10270-024-01212-x},
  volume        = {24},
  year          = {2025},
  bdsk-url-1    = {https://doi.org/10.1007/s10270-024-01212-x}
}

@inproceedings{carvalho24,
  author    = {Carvalho, Lu{\'\i}s and Costa Seco, Jo\~{a}o},
  title     = {{A Language-Based Version Control System for Python}},
  booktitle = {38th European Conference on Object-Oriented Programming (ECOOP 2024)},
  pages     = {9:1--9:27},
  series    = {Leibniz International Proceedings in Informatics (LIPIcs)},
  isbn      = {978-3-95977-341-6},
  issn      = {1868-8969},
  year      = {2024},
  volume    = {313},
  editor    = {Aldrich, Jonathan and Salvaneschi, Guido},
  publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik},
  address   = {Dagstuhl, Germany},
  url       = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.9},
  urn       = {urn:nbn:de:0030-drops-208586},
  doi       = {10.4230/LIPIcs.ECOOP.2024.9},
  annote    = {Keywords: Software evolution, type theory}
}

@online{automerge-conflicts,
  author  = {Automerge Contributors},
  title   = {Automerge Conflicts},
  year    = 2025,
  url     = {https://automerge.org/docs/reference/documents/conflicts/},
  urldate = {2025-09-14}
}

@online{couchdb-conflicts,
  author  = {Apache CouchDB Contributors},
  title   = {CouchDB Replication and Conflict Model},
  year    = 2025,
  url     = {https://docs.couchdb.org/en/stable/replication/conflicts.html#},
  urldate = {2025-09-14}
}

@article{kamina25,
  pdf       = {programming2025-evolution.pdf},
  author    = {Tetsuo Kamina and Tomoyuki Aotani and Hidehiko Masuhara},
  title     = {Evolution Language Framework for Persistent Objects},
  journal   = {The Art, Science, and Engineering of Programming},
  year      = 2025,
  volume    = 10,
  number    = 1,
  month     = feb,
  doi       = {10.22152/programming-journal.org/2025/10/12},
  date      = {2025-02-15},
  submitted = {2024-10-01},
  url       = {https://2025.programming-conference.org/}
}
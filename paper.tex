% -*- coding: utf-8; -*-
% vim: set fileencoding=utf-8 :
\documentclass[english,submission]{programming}
%% First parameter: the language is 'english'.
%% Second parameter: use 'submission' for initial submission, remove it for camera-ready (see 5.1)

\usepackage[backend=biber]{biblatex}
\addbibresource{paper.bib}

\usepackage{amsthm}
\theoremstyle{definition}
\newtheorem*{remark}{Remark}
\newtheorem*{summary}{Summary}

\usepackage{mathtools}
\usepackage{csquotes}
\usepackage{stmaryrd}

% define natbib citet
\newcommand{\citet}[1]{\citeauthor*{#1}~\cite{#1}}

\newcommand{\mathbox}[1]{\colorbox{black!10}{$#1$}}
\usepackage{tcolorbox}
\tcbset{colback=black!10, colframe=white, right=-20pt}

\DeclareMathOperator{\exec}{\fatsemi\ }
\newcommand{\isa}{\dblcolon}
\newcommand{\quotedstring}[1]{\textsf{\textquotedbl{#1}\textquotedbl}}
\newcommand{\emptystring}{\textsf{\textquotedbl\ \!\textquotedbl}}
%\DeclareMathOperator{\pipe}{|}
%\DeclareMathOperator{\at}{\textsf{@}}

%%%%%%%%%%%%%%%%%%
%% These data MUST be filled for your submission. (see 5.3)
\paperdetails{
  %% perspective options are: art, sciencetheoretical, scienceempirical, engineering.
  %% Choose exactly the one that best describes this work. (see 2.1)
  perspective=art,
  %% State one or more areas, separated by a comma. (see 2.2)
  %% Please see list of areas in http://programming-journal.org/cfp/
  %% The list is open-ended, so use other areas if yours is/are not listed.
  area={Database programming, Visual and live programming, Programming environments, Version control},
  %% You may choose the license for your paper (see 3.)
  %% License options include: cc-by (default), cc-by-nc
  % license=cc-by,
}
%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%
%% These data are provided by the editors. May be left out on submission.
%\paperdetails{
%  submitted=2016-08-10,
%  published=2016-10-11,
%  year=2016,
%  volume=1,
%  issue=1,
%  articlenumber=1,
%}
%%%%%%%%%%%%%%%%%%


\begin{document}

\title{The Many-worlds Interpretation of Programming}

\author[a]{Jonathan Edwards}[0000-0003-1958-7967]
\authorinfo{is an independent researcher interested in simplifying and democratising programming by collapsing the tech stack. He is known
for his \href{https://subtext-lang.org}{Subtext} programming language experiments and his blog at \href{https://alarmingdevelopment.org}{\texttt{alarmingdevelopment.org}}.
He has been a researcher at MIT CSAIL and CDG/HARC. He tweets \href{https://x.com/jonathoda}{\texttt{@jonathoda}} and can be reached at
\email{jonathanmedwards@gmail.com}.}
\affiliation[a]{Independent, Boston, MA, USA}

\author[b]{Tomas Petricek}[0000-0002-7242-2208]
\authorinfo{is an assistant professor at Charles University. He
is interested in finding easier and more accessible ways of thinking
about programming. To do so, he combines technical work on
programming systems and tools with research into history and
philosophy of science. His work can be found at \href{https://tomasp.net}{\texttt{tomasp.net}} and
he can be reached at \email{tomas@tomasp.net}.}
\affiliation[b]{Charles University, Prague, Czechia}


\keywords{key, word} % please provide 1--5 keywords


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Please go to https://dl.acm.org/ccs/ccs.cfm and generate your Classification
% System [view CCS TeX Code] stanz and copy _all of it_ to this place.
%% From HERE

% To HERE
%%%%%%%%%%%%%%%%%%%%%%%

\maketitle

\begin{abstract}

Action calculus is a technique of change management that generalizes conventional version control and collaborative editing systems to handle refactorings, transformations, schema evolution, and database differencing. A fragment of a new kind of query language is included. Altogether we solve $4/8$ of the challenge problems of schema evolution identified in a prior paper.
The theory is presented semi-formally and a prototype implementation is discussed. A playable demo is submitted as an artifact.

The superpower of the action calculus is transporting actions across alternate timelines while preserving their intention. The \textit{Many-worlds Interpretation of Programming}
is a research vision to extend the action calculus into a unified PL/DB/UI, solve the impedance mismatch problem, and integrate facilities for testing, package management, and deployment.
Realizing that vision would in effect be a revival of the beloved Lisp/SmallTalk live programming experience in a single unifying language, reimagined for the modern world.

\noindent\rule{\textwidth}{1pt}

% Each submission must be accompanied by a plain-language abstract of up to 500 words that presents the key points in the paper in a manner understandable by experienced practitioners and researchers in nearby disciplines. The abstract should avoid mathematical symbols whenever possible, and it must address the following:
% Context: What is the broad context of the work? What is the importance of the general research area?
Context: The programming tech stack has inflated to mind-boggling proportions. We must seek ways to simplify programming, if only in certain domains.

% Inquiry: What problem or question does the paper address? How has this problem or question been addressed by others (if at all)?
Inquiry: Problems of change management recur in many guises throughout programming. Is this a point of attack where a general technique can leverage widespread benefits? We generalize upon prior work in version control and collaborative editing systems.

% Approach: What was done that unveiled new knowledge?
Approach: In prior work we identified eight challenge problems of schema evolution in programming systems. We developed the action calculus initially to solve two of these. The key move was to shift the focus from states to high-level actions.

% Knowledge: What new facts were uncovered? If the research was not results oriented, what new capabilities are enabled by the work?
Knowledge: We discovered a new technique of change management that works on timelines of high-level actions, not primitive state edits. It offers a much-simplified conceptual model for version control. We iteratively designed a new GUI for visualizing nesting and relationships and differencing them.

% Grounding: What argument, feasibility proof, artifacts, or results and evaluation support this work?
Grounding: We solve $4/8$ of the challenge problems of schema evolution identified in prior work.
The action calculus has iterated through two prior workshop papers. Demos were used for feedback on the GUI, leading to two complete redesigns.

% Importance: Why does this work matter?
Importance: Version control and schema evolution are sources of much complaint that deserve improved solutions. More generally we need to research cures for the Complexity Cancer afflicting programming.

\end{abstract}






\section{Introduction}

We observe that \textit{change managment} is a central problem throughout the theory and practice of programming, albeit appearing in many guises. The goal of this paper is to convert that observation into a research vision of new general purpose techniques for change management that can yield benefits across diverse aspects of programming and software development. To motivate and substantiate this vision we offer a first step: a technique of change managment called \textit{action calculus} that we apply to demonstrate several novel capabilities.

Problems of change management appear in many guises:
\begin{itemize}

  \item Programming ultimately happens by changing code. There are well-established tools for managing changes to source code but also much discontent with them, indicating a pent-up demand for something better (\S\ref{VC}).
  % Because extant version control systems work at the level of text, they lose much of the intention of programmers, so for example a system-wide rename refactoring appears as many differences and conflicts rather than one.

  \item Managing state change is a deep concern in the design of programming languages. A central principle of functional programming is to reject mutable state in favor of abstractions like monads and lenses. For their part, imperative languages utilize complex state management libraries. (\S\ref{PLstate})

  \item Much code is required to translate data changes between a UI, PL data structures, and a DB. It seems like much less code ought to be needed, but extensive research on this \textit{impedance mismatch problem} has not produced a decisive solution (\S\ref{impedance}).

  \item Collaborative editing and data synchronization engines are concerned with automatically transporting and reconciling changes, applying the techniques of Operational Transformation (OT \S\ref{OT}) and Convergent Replicated DataTypes (CRDTs \S\ref{CRDT}).

  \item Database schema change necessitates data migration and query rewriting. Live programming faces a similar problem when state becomes stale. There has been much research on \textit{schema evolution} but in practice it is still largely manual and ad hoc (\S \ref{schema}).

  \item Tests sometimes simulate input changes, mock output changes, and check for expected changes. Tests sometimes snapshot a system state for convenient comparison, but then can't detect when it is stale.

  \item Changes in dev must be deployed to prod.
  % Why must that be more involved than switching branches?
  Sometimes code changes are wrapped inside feature flags that turn them into runtime changes.
  % Why can't that be an automated refactoring?

  \item Changes in upstream dependencies must be installed, often via elaborate and fragile package management systems.
  % Why must that be more complicated than accepting a pull request?

\end{itemize}

% commented out criticisms above becuase they may just invite objections
\medskip
The list could go on. But it is all too easy to notice patterns and draw analogies. Is there some shared essence that can be distilled into a theory and leveraged in a tool to practical benefit? We conjecture yes, though with the caveat that it may be necessary to break compatibility with the established tech stack, at least at first. We believe it would still be a valuable result to show that a unified approach to change management can  simplify multiple aspects of programming, even if at first only in a Petri dish.
Likewise we argue that performance concerns be deferred.

With that said we propose a new technique of change management called the \textit{action calculus}. Action calculus differs from familiar techniques in that:
\begin{enumerate}

  \item It starts by defining the data model of a class of artifacts along with a system of actions upon that model. These actions capture high-level design changes such as transformations and refactorings, not just primitive edit operations in the model (or even worse, edits to a textual syntax).

  \item The history of actions on an artifact is recorded in a \textit{timeline} by monitoring the API and a GUI that manifests actions as direct manipulations.
  Because actions know more about the user's intent than primitive edits, an action timeline contains more information than the final state or even the entire history of states.

  \item Timelines can be compared to compute the differences between artifacts, expressed as a hypothetical timeline in which a maximally common ancestor was first created and then the two artifacts forked off with minimally diverging timelines. Note that this common ancestor may not have ever actually existed.
  Differential timelines are more accurate than lower-level techniques because they take into account structural transformations and refactorings.

  \item The key feature of the action calculus is the ability to \textit{transport} individual actions across forking timelines while preserving the actions's intent (which is given a precise meaning).
  %Familiar change management operations like \textit{merging} are implemented with transportation.
  %Differencing is also done through transportation.
  We say that transportation explores the \textit{multiverse} of alternate timelines of an artifact\footnote{It is well known that a transporter can access and create alternate timelines\cite{mirrormirror}}.

  %\item Transportation is itself built upon the core mechanism of the calculus: \textit{time travel}, shifting an action forward or backward in time to generate an alternate timeline with the same final state.

\end{enumerate}

Our research conjecture is that the action calculus can be applied beneficially to the varied problems of change management in programming that were listed above (and others not listed). Since the action calculus explores the multiverse of alternate histories we call our conjecture the Many-worlds Interpretation of Programming.

\noindent\textcolor{red}{Maybe too cute. Alternate titles:\\
Action Calculus: Programming in the Multiverse\\
Action Calculus: Managing the Multiverse\\
Programming in the Multiverse\\
Managing the Multiverse\\
}

Realizing that conjecture would in effect be a revival of the classic Lisp/SmallTalk live programming experience in a single unifying language, reimagined for the modern world. But for now this is a far-off research vision that we offer
as the motivation of our work and we hope as an inspiration for others. The concrete contributions of this paper are:

\begin{enumerate}

  \item We semi-formally define the action calculus on a simple data model. The capabilities of the calculus are explained by example. We simplify the baroque conceptual models of version control into an open world of artifacts with append-only histories where branching is just copying. Transforming between a scalar and a list is used as a point of comparison with other techniques.

  \item We extend the simple data model to include relationships, along with actions to handle common schema refactorings in relational databases. The motivating example is normalizing a table by splitting and deduping.

  \item We present a GUI design for visualizing nesting and relationships. It also visualizes differences even in the presence of structural transformations. We discuss the design tradeoffs explored in the iterative evolution of this GUI.

  \item We submit a \textit{playable demo} as an acccompanying artifact. This demo lets you directly experience the GUI and be guided through the database normalization scenario. We hope that playable demos offer a new way to evaluate HCI research.

  \item We present the first steps towards extending the action calculus into a query language. Although only a preliminary prototype it demonstrates the key idea that a function can be seen as a hypothetical timeline of imperative actions that extracts the result from the final state. We show one benefit of this approach: Programming by Demonstration (PbD). Another benefit is that \textit{query rewriting} falls out for free from transporting schema changes. We communicate these very preliminary results because the community may find them intriguing and controversial.

  \item Altogether we solve $4/8$ of the challenge problems of schema evolution in a prior paper\cite{challenge-problems}.

\end{enumerate}








\section{Simple Historical Structures}

We introduce action calculus in a simple and familiar setting: nested lists and records. The atomic values are strings, supplied in the set \mathbox{S}, and numbers, supplied in \mathbox{N}, including \mathbox{\textsf{NaN}}. What is unusual about this data model is that we assign permanent unique identifiers (IDs) to every record field and list element. These IDs are supplied in the disjoint sets \mathbox{F} for record fields and \mathbox{E} for list elements. There are two special list element IDs: \mathbox{*} and \mathbox{\mathbb{1}}. Another unusual feature is that deletion of a record field or list element leaves behind a \textit{tombstone}. IDs and tombstones are invisible to both the user and the program -- they record historical information utilized by the action calculus. We discuss this design decision in ***.

The model is homogeneously typed similarly to statically typed functional programming (FP) language such as ML, as follows. List elements all have the same type as defined in the type of the list (except tombstones). Record values have the same sequence of fields with the same ID and type of value as in the type of the record. The elements of a list nd the fields of a record must have different IDs.
%Record fields are named with a string which need not be unique.
The empty record \mathbox{\text{\{\}}}serves as a unit type. Every type has an \textit{initial value}. We define the syntax of this model:

\tcbox{
\[ \begin{array}{rl|rl|rl|l}
  \multicolumn{2}{l|}{\textrm{type}} & \multicolumn{2}{l|}{\textrm{value}} & \multicolumn{2}{l|}{\textrm{initial value}}&\\
  \hline
  T \Coloneqq & & v \Coloneqq & & T^\varnothing = & &\\
  &  \textsf{String} & & S & & \emptystring & \textrm{string}\\
  & \textsf{Number} & &  N & & \textsf{NaN} & \textrm{number}\\
  & \textsf{List } T & & [ E : v \  \dots ] & & [] & \textrm{list}\\
  %& \{ F \  S : T \  \dots \} & & \{ F : v \  \dots \} & & \{ F : T^\varnothing \  \dots \}& \textrm{record}\\
  & \{ F : T \  \dots \} & & \{ F : v \  \dots \} & & \{ F : T^\varnothing \  \dots \}& \textrm{record}\\

  & \bot && \bigtimes & & \bigtimes & \textrm{tombstone}\\
\end{array}\]
}

A \textit{path} is a possibly empty sequence of IDs denoting a path drilling into nested records and lists. Paths can access both values and types. We construct paths with slashes as in Unix file paths. The special element ID~\mathbox{*} is used to access the element type of a list type.

A \textit{state} pairs a value with its type. We abuse the notation \mathbox{v \isa T} to both denote a state and assert that the value matches the type.
An \textit{action} is an operation on states, converting a \textit{pre-state} into a \textit{post-state}.
All actions take a \textit{target} path as a parameter indicating that the action is to be performed at that path within the state.
For example the \textsf{write} action takes a value as another parameter and writes that value into the target path. Actions are not defined for all pre-states. The \textsf{write} action requires that the target path exists in the value and that its type matches the value parameter. We define actions as terms of a grammer,
using infix syntax, placing the target path first, then the action name, followed by any other parameters, like this:
\mathbox{\mathit{writeAction} \Coloneqq p \textsf{ write } v}


Table of actions


We execute actions with the \mathbox{\fatsemi} infix operator taking a pre-state on the left, an action on the right, and yielding a post-state which may be chained into subsequent executions. Here is a concrete example defining a record type \mathbox{\mathit{Name}} given field IDs \mathbox{\mathit{first}} and \mathbox{\mathit{last}}:

%\begin{tcolorbox}[nobeforeafter]
\begin{align*}
%\mathit{Name} &= \{\mathit{first}\  \quotedstring{first}: \textsf{String},\  \mathit{last}\  \quotedstring{last}: \textsf{String}\}\\
\mathit{Name} &= \{\mathit{first}  : \textsf{String},\  \mathit{last} : \textsf{String}\}\\
s_1 &= \{\mathit{first}: \quotedstring{John},\  \mathit{last}: \quotedstring{Smith}\} \isa \mathit{Name}\\
s_2 &= s_1 \exec \mathit{last} \textsf{ write } \quotedstring{Smythe}\\
&= \{\mathit{first}: \quotedstring{John},\  \mathit{last}: \quotedstring{Smythe}\} \isa \mathit{Name}\\
\end{align*}
%\end{tcolorbox}

The \textsf{write} action is a \textit{value action}, meaning it does not modify the type of the state. On the other hand \textit{type actions} may modify both the type and value. By convention we capitalize the name of type actions. Our system has a \textit{user mode} in which only value actions are permitted.

\begin{remark}
In this presentation we have adopted the conventional approach of defining values and types as distinct objects. However our implementation only has values, with initial values serving as prototypes. Every list contains an initial \textit{header} element with the ID~\mathbox{*} containing an initial value which serves as the prototype of the list elements. Note how this convention corresponds to the visual rendering of a table where a header row describes the type of each column. Types are a powerful abstraction for the theory and implementation of programming systems but we conjecture that they can be replaced with prototypes, without loss of power, to simplify the programming experience. We have also explored an untyped action calculus\cite{denicek}, but that is not the topic of this paper.
\end{remark}

The \textsf{Define} action is the type-level equivalent of \textsf{write}: \mathbox{p \textsf{ Define } T}. The path $p$ must exist in the state's type, in which case it is changed into the new type $T$. Any path in the state's value that \textit{corresponds} to the path $p$ is changed into the initial value of the new type $T^\varnothing$. A value path $q$ correspond to a type path $p$ iff replacing every list element ID in $q$ with $*$ makes it equal to $p$. In other words, the initial value is written into all list elements corresponding to a list type. For example:

% mention untyped approach of * as a selector. We use homogenous typing of lists to drive iteration declaratively.

\begin{align*}
s_1 &= [ e_1: 1,\  e_2: 2] \isa \textsf{List Number}\\
s_2 &= s_1 \exec * \textsf{ Define } \textsf{String}\\
    &= [ e_1: \emptystring,\  e_2: \emptystring] \isa \textsf{List String}\\
\end{align*}

The \textsf{Define} action is typically used to define new types. To change the type of populated data as in the above example the \textsf{Convert} action is more useful. For example:

\begin{align*}
s_1 &= [ e_1: 1,\  e_2: 2] \isa \textsf{List Number}\\
s_2 &= s_1 \exec * \textsf{ Convert } \textsf{String}\\
    &= [ e_1: \quotedstring{1},\  e_2: \quotedstring{2}] \isa \textsf{List String}\\
\end{align*}

What happens if we convert a string into a number but the string doesn't parse as a number? There are many design choices like this when defining a system of actions, with different tradeoffs. One might choose to yield \textsf{NaN}. Our implementation instead wraps the string in an error value that can be repaired later in the UI.

The \textsf{Convert} action can only convert between atomic types like strings and numbers. Structural transformations are handled with different actions, which is where things get interesting.



% These definitions follow naturally:
% \[ \begin{array}{cl}
%   \mathbox{\textsf{v} \textsf{ isa } \textsf{T}} & \textrm{iff value \mathbox{\textsf{v}} matches type \mathbox{\textsf{T}}}.\\

%   \mathbox{\textsf{T}\lfloor\textsf{p}\rfloor?} & \textrm{iff path \mathbox{\textsf{p}} exists in type \mathbox{\textsf{T}}} \textrm{, in which case}\\
%   & \mathbox{\textsf{T}\lfloor\textsf{p}\rfloor} \textrm{ is the type at that path and }\\
%   & \mathbox{\textsf{T}\lceil\textsf{p} \coloneqq \textsf{T}_\textsf{2}\rceil} \textrm{ is \textsf{T} with } \mathbox{\textsf{T}_\textsf{2}} \textrm{ substituted at that path.}\\
%   & \textsf{The special element ID \mathbox{*} is defined to access the type of a list, as will any element ID:}\\
%   & \mathbox{\forall e \in E \ldotp (\textsf{List T})\lfloor e \rfloor = \textsf{T}}.
%   \\

%   \mathbox{\textsf{v}\lfloor\textsf{p}\rfloor?} &\textrm{iff path \mathbox{\textsf{p}} exists in value \mathbox{\textsf{v}}} \textrm{, in which case }\\
%   & \mathbox{\textsf{v}\lfloor\textsf{p}\rfloor} \textrm{ is the value at that path and}\\
%   & \mathbox{\textsf{v}\lceil\textsf{p} \coloneqq \textsf{v}_\textsf{2}\rceil} \textrm{ is \textsf{v} with } \mathbox{\textsf{v}_\textsf{2}} \textrm{ substituted at that path.}\\
% \end{array}\]


\section{Transportation}
Transport by example: pluralize, insert

\subsection{Projection and retraction}

\subsection{Branchless diffing}
Conceptual model
Algorithm

\section{Relationships and normalization}

\section{Visualizing the multiverse}
\subsection{Exploring structure}
\subsection{Relating variants}
\subsection{A playable demo}

\section{Queries as hypotheticals}
\subsection{PbD}
\subsection{Query rewriting via projection}


\section{Related work}

actually related work:
Alex's worlds. Roly. Ask them for comment?
Challenge problem paper.
I\&S: cambria, peritext, universal version control
Braid time machine https://braid.org/time-machines

\subsection{Version control}\label{VC}

git, darcs, pijul

git is the most established tool for change management but is also the source of much discontent. Pull refs from schema change paper. santiago's stuff. intentional?

\subsection{The impedance mismatch problem} \label{impedance}

orthogonal persistence, ORMs, Linq, single tier (Tier, hop), naked objects, DBOS, durable computation

\subsection{PL state management}\label{PLstate}

FP: Monads, Lenses

Imperative: immutable, React state menagement

\subsection{OT}\label{OT}

\subsection{CRDT}\label{CRDT}

\subsection{Schema Evolution}\label{schema}
just ref challenge problems paper?



\section{Discussion}
pros and cons

caveats, weaknesses, open problems

\section{Commencement}
summary and call to action

\printbibliography

\end{document}

% Local Variables:
% TeX-engine: luatex
% End:

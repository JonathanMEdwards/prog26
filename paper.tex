% -*- coding: utf-8; -*-
% vim: set fileencoding=utf-8 :
\documentclass[english,submission]{programming}
%% First parameter: the language is 'english'.
%% Second parameter: use 'submission' for initial submission, remove it for camera-ready (see 5.1)

\usepackage[backend=biber]{biblatex}
\addbibresource{paper.bib}

\usepackage{amsthm}
\theoremstyle{definition}
\newtheorem*{remark}{Remark}
\newtheorem*{summary}{Summary}

\usepackage{mathtools}
\usepackage{csquotes}
\usepackage{stmaryrd}
 \usepackage{quiver}

% define natbib citet
\newcommand{\citet}[1]{\citeauthor*{#1}~\cite{#1}}

\newcommand{\mathbox}[1]{\colorbox{black!10}{$#1$}}
\usepackage{tcolorbox}
\tcbset{colback=black!10, colframe=white, right=-20pt}

\DeclareMathOperator{\exec}{\ \fatsemi\ \ }
\newcommand{\is}{{:}\ }
\newcommand{\comma}{,\ }
\newcommand{\isa}{\dblcolon}
\newcommand{\quotedstring}[1]{\textsf{\textquotedbl{#1}\textquotedbl}}
\newcommand{\emptystring}{\textsf{\textquotedbl\ \!\textquotedbl}}
%\DeclareMathOperator{\pipe}{|}
%\DeclareMathOperator{\at}{\textsf{@}}

%%%%%%%%%%%%%%%%%%
%% These data MUST be filled for your submission. (see 5.3)
\paperdetails{
  %% perspective options are: art, sciencetheoretical, scienceempirical, engineering.
  %% Choose exactly the one that best describes this work. (see 2.1)
  perspective=art,
  %% State one or more areas, separated by a comma. (see 2.2)
  %% Please see list of areas in http://programming-journal.org/cfp/
  %% The list is open-ended, so use other areas if yours is/are not listed.
  area={Database programming, Visual and live programming, Programming environments, Version control},
  %% You may choose the license for your paper (see 3.)
  %% License options include: cc-by (default), cc-by-nc
  % license=cc-by,
}
%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%
%% These data are provided by the editors. May be left out on submission.
%\paperdetails{
%  submitted=2016-08-10,
%  published=2016-10-11,
%  year=2016,
%  volume=1,
%  issue=1,
%  articlenumber=1,
%}
%%%%%%%%%%%%%%%%%%


\begin{document}

\title{Baseline: Verson Control All the Way Down}

\author[a]{Jonathan Edwards}[0000-0003-1958-7967]
\authorinfo{is an independent researcher interested in simplifying and democratising programming by collapsing the tech stack. He is known
for his \href{https://subtext-lang.org}{Subtext} programming language experiments and his blog at \href{https://alarmingdevelopment.org}{\texttt{alarmingdevelopment.org}}.
He has been a researcher at MIT CSAIL and CDG/HARC. He tweets \href{https://x.com/jonathoda}{\texttt{@jonathoda}} and can be reached at
\email{jonathanmedwards@gmail.com}.}
\affiliation[a]{Independent, Boston, MA, USA}

\author[b]{Tomas Petricek}[0000-0002-7242-2208]
\authorinfo{is an assistant professor at Charles University. He
is interested in finding easier and more accessible ways of thinking
about programming. To do so, he combines technical work on
programming systems and tools with research into history and
philosophy of science. His work can be found at \href{https://tomasp.net}{\texttt{tomasp.net}} and
he can be reached at \email{tomas@tomasp.net}.}
\affiliation[b]{Charles University, Prague, Czechia}


\keywords{key, word} % please provide 1--5 keywords


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Please go to https://dl.acm.org/ccs/ccs.cfm and generate your Classification
% System [view CCS TeX Code] stanz and copy _all of it_ to this place.
%% From HERE

% To HERE
%%%%%%%%%%%%%%%%%%%%%%%

\maketitle

\begin{abstract}

Action calculus is a technique of change management that generalizes conventional version control and collaborative editing systems to handle refactorings, transformations, schema evolution, and database differencing. We take the first steps of extending it into a new kind of query language. Altogether we solve four of the eight challenge problems of schema evolution identified in a prior paper.
The theory is presented semi-formally and a prototype implementation is discussed. A playable demo is submitted as an artifact.

The superpower of the action calculus is transporting actions across alternate timelines while preserving their intention. The \textit{Many-worlds Interpretation of Programming}
is a research vision to extend this power into a unified PL/DB/UI, solve the impedance mismatch problem, and integrate facilities for testing, package management, and deployment.
Realizing that vision would in effect be a revival of the beloved Lisp/SmallTalk unified programming experience, reimagined for the modern world.

\noindent\rule{\textwidth}{1pt}

% Each submission must be accompanied by a plain-language abstract of up to 500 words that presents the key points in the paper in a manner understandable by experienced practitioners and researchers in nearby disciplines. The abstract should avoid mathematical symbols whenever possible, and it must address the following:
% Context: What is the broad context of the work? What is the importance of the general research area?
Context: The programming tech stack has inflated to mind-boggling proportions. We must seek ways to simplify programming, if only in certain domains.

% Inquiry: What problem or question does the paper address? How has this problem or question been addressed by others (if at all)?
Inquiry: Problems of change management recur in many guises throughout programming. Is this a point of attack where a general technique can leverage widespread benefits? We generalize upon prior work in version control and collaborative editing systems.

% Approach: What was done that unveiled new knowledge?
Approach: In prior work we identified eight challenge problems of schema evolution in programming systems. We developed the action calculus initially to solve two of these. The key move was to shift the focus from states to high-level actions.

% Knowledge: What new facts were uncovered? If the research was not results oriented, what new capabilities are enabled by the work?
Knowledge: We discovered a new technique of change management that works on timelines of high-level actions, not primitive state edits. It offers a much-simplified conceptual model for version control. We iteratively designed a new GUI for visualizing nesting and relationships and differencing them.

% Grounding: What argument, feasibility proof, artifacts, or results and evaluation support this work?
Grounding: We solve four of the eight challenge problems of schema evolution identified in prior work.
The action calculus has iterated through two prior workshop papers. Demos were used for feedback on the GUI, leading to two complete redesigns.

% Importance: Why does this work matter?
Importance: Version control and schema evolution are sources of much complaint that deserve improved solutions. More generally we need to research cures for the Complexity Cancer afflicting programming.

\end{abstract}






\section{Introduction}

We observe that \textit{change managment} is a central problem throughout the theory and practice of programming, albeit appearing in many guises. The goal of this paper is to convert that observation into a research vision of new general purpose techniques for change management that can yield benefits across diverse aspects of programming and software development. To motivate and substantiate this vision we offer a first step: a technique of change managment called \textit{action calculus} that we apply to demonstrate several novel capabilities.

Problems of change management appear in many guises:
\begin{itemize}

  \item Programming ultimately happens by changing code. There are well-established tools for managing changes to source code but also much discontent with them, indicating a pent-up demand for something better (\S\ref{VC}).
  % Because extant version control systems work at the level of text, they lose much of the intention of programmers, so for example a system-wide rename refactoring appears as many differences and conflicts rather than one.

  \item Managing state change is a deep concern in the design of programming languages. A central principle of functional programming is to reject mutable state in favor of abstractions like monads and lenses. For their part, imperative languages utilize complex state management libraries. (\S\ref{PLstate})

  \item Much code is required to translate data changes between a UI, PL data structures, and a DB. It seems like much less code ought to be needed, but extensive research on this \textit{impedance mismatch problem} has not produced a decisive solution (\S\ref{impedance}).

  \item Collaborative editing and data synchronization engines are concerned with automatically transporting and reconciling changes, applying the techniques of Operational Transformation (OT \S\ref{OT}) and Convergent Replicated DataTypes (CRDTs \S\ref{CRDT}).

  \item Database schema change necessitates data migration and query rewriting. Live programming faces a similar problem when state becomes stale. There has been much research on \textit{schema evolution} but in practice it is still largely manual and ad hoc (\S \ref{schema}).

  \item Tests sometimes simulate input changes, mock output changes, and check for expected changes. Tests sometimes snapshot a system state for convenient comparison, but then can't detect when it is stale.

  \item Changes in dev must be deployed to prod.
  % Why must that be more involved than switching branches?
  Sometimes code changes are wrapped inside feature flags that turn them into runtime changes.
  % Why can't that be an automated refactoring?

  \item Changes in upstream dependencies must be installed, often via elaborate and fragile package management systems.
  % Why must that be more complicated than accepting a pull request?

\end{itemize}

% commented out criticisms above becuase they may just invite objections
\medskip
The list could go on. But it is all too easy to notice patterns and draw analogies. Is there some shared essence that can be distilled into a theory and leveraged in a tool to practical benefit? We conjecture yes, though with the caveat that it may be necessary to break compatibility with the established tech stack, at least at first. We believe it would still be a valuable result to show that a unified approach to change management can  simplify multiple aspects of programming, even if at first only in a Petri dish.
Likewise we argue that performance concerns be deferred.

With that said we propose a new technique of change management called the \textit{action calculus}. Action calculus differs from familiar techniques in that:
\begin{enumerate}

  \item It starts by defining the data model of a class of artifacts along with a system of actions upon that model. These actions capture high-level design changes such as transformations and refactorings, not just primitive edit operations in the model (or even worse, edits to a textual syntax).

  \item The history of actions on an artifact is recorded in a \textit{timeline} by monitoring the API and a GUI that manifests actions as direct manipulations.
  Because actions know more about the user's intent than primitive edits, an action timeline contains more information than the final state or even the entire history of states.

  \item Timelines can be compared to compute the differences between artifacts, expressed as a hypothetical timeline in which a maximally common ancestor was first created and then the two artifacts forked off with minimally diverging timelines. Note that this common ancestor may not have ever actually existed.
  Differential timelines are more accurate than lower-level techniques because they take into account structural transformations and refactorings.

  \item The key feature of the action calculus is the ability to \textit{transport} individual actions across forking timelines while preserving the actions's intent (which is given a precise meaning).
  %Familiar change management operations like \textit{merging} are implemented with transportation.
  %Differencing is also done through transportation.
  We say that transportation navigates the \textit{multiverse} of alternate timelines of an artifact.

  %\item Transportation is itself built upon the core mechanism of the calculus: \textit{time travel}, shifting an action forward or backward in time to generate an alternate timeline with the same final state.

\end{enumerate}

Our research conjecture is that the action calculus can be applied beneficially to the varied problems of change management in programming that were listed above, and more. Since the action calculus navigates the multiverse of alternate histories we call our conjecture the Many-worlds Interpretation of Programming.

Realizing that conjecture would in effect be a revival of the beloved Lisp/SmallTalk unified programming experience, reimagined for the modern world. But for now this is a far-off research vision that we offer
as the motivation of our work and we hope as an inspiration for others. The concrete contributions of this paper are:

\begin{enumerate}

  \item We semi-formally define the action calculus on a simple data model. The capabilities of the calculus are explained by example. We simplify the baroque conceptual models of version control into an open world of artifacts with append-only histories where branching is just copying. Transforming between a scalar and a list is used as a point of comparison with other techniques.

  \item We extend the simple data model to include relationships, along with actions to handle common schema refactorings in relational databases. The motivating example is normalizing a table by splitting and deduping.

  \item We present a GUI design for visualizing nesting and relationships. It also visualizes differences even in the presence of structural transformations. We discuss the design tradeoffs explored in the iterative evolution of this GUI.

  \item We submit a \textit{playable demo} as an acccompanying artifact. This demo lets you directly experience the GUI and be guided through the database normalization scenario. We hope that playable demos offer a new way to evaluate HCI research.

  \item We take the first steps of extending the action calculus into a query language. Although only a preliminary prototype it demonstrates the key idea that a function can be seen as a hypothetical timeline of imperative actions that extracts the result from the final state. We show one benefit of this approach: Programming by Demonstration (PbD). Another benefit is that \textit{query rewriting} falls out for free from transporting schema changes. We communicate these very preliminary results because the community may find them intriguing and controversial.

  \item Altogether we solve four of the eight challenge problems of schema evolution in a prior paper\cite{challenge-problems}.

\end{enumerate}








\section{Simple Structural Action}

We introduce action calculus in a simple and familiar setting: nested lists and records. The atomic values are strings, supplied in the set \mathbox{S}, and numbers, supplied in \mathbox{N}, including \mathbox{\textsf{NaN}}. What is unusual about this data model is that we assign permanent unique identifiers (IDs) to every record field and list element. These IDs are supplied in the disjoint sets \mathbox{F} for record fields and \mathbox{E} for list elements. Because record fields have unique IDs their names are only for human readability and we elide in them in most examples. Another unusual feature is that deletion of a record field or list element leaves behind a \textit{tombstone}.

\begin{remark}
IDs and tombstones are invisible to both the user and the program. They only affect action transportation (and performance). We believe they are not necessary and have prototyped implementations without them (in fact Baseline currently doesn't use tombstones), but that adds a lot of complexity. We adopt them here in the interest of simplicity.
% IDs are replaced with numerical offsets. Much more path adjustment has to happen.
\end{remark}

The model is homogeneously typed similarly to statically typed functional programming (FP) language such as ML, as follows. List elements all have the same type as defined in the type of the list (except tombstones). Record values have the same sequence of fields with the same ID and type of value as in the type of the record. The elements of a list nd the fields of a record must have different IDs.
%Record fields are named with a string which need not be unique.
The empty record \mathbox{\text{\{\}}}serves as a unit type. Every type has an \textit{initial value}. We define the syntax of this model:

% simple syntax table
\tcbox{
\[ \begin{array}{r@{\ }l|r@{\ }l|r@{\ }l|l}
  \multicolumn{2}{l|}{\textrm{type}} & \multicolumn{2}{l|}{\textrm{value}} & \multicolumn{2}{l|}{\textrm{initial value}}&\\
  \hline
  T \Coloneqq & & v \Coloneqq & & T^\varnothing = & &\\
  &  \textsf{String} & & S & & \emptystring & \textrm{string}\\
  & \textsf{Number} & &  N & & \textsf{NaN} & \textrm{number}\\
  & \textsf{List } T & & [ E \is v \  \dots ] & & [] & \textrm{list}\\
  %& \{ F \  S \is T \  \dots \} & & \{ F \is v \  \dots \} & & \{ F \is T^\varnothing \  \dots \}& \textrm{record}\\
  & \{ F \  S \is T \  \dots \} & & \{ F \is v \  \dots \} & & \{ F \is T^\varnothing \  \dots \}& \textrm{record}\\

  & \bot && \bigtimes & & \bigtimes & \textrm{tombstone}\\
\end{array}\]
}

A \textit{path} is a possibly empty sequence of IDs denoting a path drilling into nested records and lists. Paths can access both values and types. We separate the IDs in a path with dots, and a single dot is the empty (top) path. A special element ID~\mathbox{*} is used to access the element type of a list type.

A \textit{state} pairs a value with its type. We abuse the notation \mathbox{v \isa T} to both denote a state and assert that the value matches the type.
An \textit{action} is an operation on states, converting an \textit{input state} into a \textit{output state}. Actions are not defined on all input states, imposing various preconditions.
All actions take a \textit{target} path as a parameter indicating that the action is to be performed at that path within the state.
% For example the \textsf{write} action takes a value as another parameter and writes that value into the target path. Actions are not defined for all  input states. The \textsf{write} action requires that the target path exists in the value and that its type matches the value parameter.
We define actions as terms of a grammer,
using infix syntax, placing the target path first, then the action name, followed by any other parameters. Here are the actions on simple structures:

% simple actions table
\tcbox{
\[
\hspace{-22pt}
\begin{array}{l|l}
  \textrm{Value actions} & \\
  \hline
  p \textsf{ noop} & \textrm{Do nothing}\\
  p \textsf{ write } v & \textrm{Write atomic value $v$ at $p$}\\

  p \textsf{ insert } E \textsf{ before } E' & \textrm{Insert element ID $E$ into list at $p$ in front of element $E'$}\\
  p \textsf{ append } E & \textrm{Append element ID $E$ to end of list at $p$}\\

  p \textsf{ delete } E & \textrm{Delete element ID $E$ in list at $p$}\\

  p \textsf{ moveFrom } p' & \textrm{List element at $p$ is overwritten from $p'$ in the same list}\\
  & \textrm{or cousin in nested lists, and $p'$ is deleted}\\
  \hline

  \textrm{Type actions} & \rule[0pt]{0pt}{16pt}\\
  \hline
  p \textsf{ Define } T & \textrm{Define $p$ to have type $T$, initializing values}\\
  p \textsf{ Convert } T & \textrm{Convert $p$ to atomic type $T$}\\

  p \textsf{ Rename } S & \textrm{Rename record field $p$ to string $S$}\\

  p \textsf{ Insert } F \textsf{ before } F' & \textrm{Insert field ID $F$ into record at $p$ in front of field $F'$}\\
  p \textsf{ Append } F & \textrm{Append field ID $F$ to end of record at $p$}\\

  p \textsf{ Delete } F & \textrm{Delete field ID $F$ in record at $p$}\\

  p \textsf{ MoveFrom } p' & \textrm{Record field at $p$ is overwritten from $p'$ in the same record}\\
  & \textrm{or containing\slash contained record, and $p'$ is deleted}\\


  p \textsf{ ListOf } & \textrm{Convert value at $p$ into a list of one element with ID $\mathbb{1}$}\\
  p \textsf{ IntoFirst } & \textrm{Convert list at $p$ into its first element, else the initial value} \\

  p \textsf{ RecordOf } F & \textrm{Convert value at $p$ into a record of one field with ID $F$} \\
  p \textsf{ IntoField } F & \textrm{Convert record at $p$ into value of its field $F$} \\

\end{array}\]
}



We execute actions with the \mathbox{\fatsemi} infix operator taking an input state on the left, an action on the right, and yielding an output state which may be chained into subsequent executions. Here is an example that starts with an empty list of numbers and adds an element $e$ with value $1$:
\begin{align*}
S_1 &= [] \isa \textsf{List Number}\\
S_2 &= S_1 \exec \ldotp \textsf{ append } e \exec e \textsf{ write } 1\\
&= [e \is 1] \isa \textsf{List Number}\\
\end{align*}
The \textsf{append} action targets the empty path \mathbox{\ldotp} referring to the whole list. Then the \textsf{write} action targets the new element with the path \mathbox{e} which is an abbreviation for \mathbox{.e}. In all our examples we take IDs like $e$ as given but in practice the Baseline API generates them uniquely.

A \textit{table} is a list of records, the fields of which are the \textit{columns} while the elements of the list are the \textit{rows}. Here is an example of changing the type of a table:
\begin{align*}
S_1 &= [e \is \{x \is 1 \comma  y \is 2\}] \isa \textsf{List} \{x \is \textsf{Number}\comma  y \is \textsf{Number}\}\\
S_2 &= S_1 \exec * \textsf{ Append } z \exec *\ldotp z \textsf{ Define Number}\\
 &= [e \is \{x \is 1\comma  y \is 2,\ z\is \textsf{NaN}\}] \isa \textsf{List} \{x \is \textsf{Number}\comma  y \is \textsf{Number}\comma z\is \textsf{Number}\}\\
\end{align*}
The \textsf{Append} action targets the path \mathbox{*} which is the record type of the list's elements and adds a new field \mathbox{z} to it, in effect adding a column to the table. The \textsf{Define} action targets the path \mathbox{*\ldotp z} which is the type of the new field (initially the unit type $\{\}$) and changes it to \textsf{Number}. The new field is also inserted into all elements of the list with the initial value \textsf{NaN}.

The \textsf{append} and \textsf{write} actions are \textit{value actions}, meaning they do not modify the type of the state. On the other hand \textsf{Append} and \textsf{Define} are \textit{type actions} that may modify both the type and value. Type actions do what databases call \textit{schema migration}: the value is adapted to match the type while minimizing loss of information, iterating over list elements as needed (think of the $*$ in the type path as a wildcard). By convention we capitalize the name of type actions. Baseline has a \textit{user mode} in which only value actions are permitted.

\begin{remark}
In this presentation we adopt the standard approach of defining values and types as distinct objects. However Baseline only has values, with initial values serving as prototypes. Every list contains an initial \textit{header} element with the ID~\mathbox{*} containing an initial value which serves as the prototype of the list elements. Note how this convention corresponds to the visual rendering of a table where a header row describes the type of each column. Types are a powerful abstraction for the theory and implementation of programming systems but we conjecture that they can be replaced with prototypes, without loss of power, to simplify the programming experience. We have also explored an untyped version of our approach~\cite{denicek}.
\end{remark}

Many of the type actions exist in order to do schema migration on values: they are not neeeded just to define a type prior to populating it with data. We think of these actions as \textit{type refactorings}, capturing high-level design changes, and manifesting in the GUI as direct manipulations. Schema migration is also a challenging problem for \textit{live programming}~\cite{challenge-problems}.
\begin{figure}[h]
\begin{align*}
  S_1 &= [
    e \is \{ \mathit{what}\is \quotedstring{clean}\comma  \mathit{who}\is \quotedstring{Jack} \}
    ] \isa
    \textsf{List}\{ \mathit{what}\is \textsf{String}\comma \mathit{who}\is \textsf{String} \}\\
S_2 &= S_1 \exec *\ldotp \mathit{who} \textsf{ ListOf } \\
 &= [
    e \is \{ \mathit{what}\is \quotedstring{clean}\comma  \mathit{who}\is [\mathbb{1}\is \quotedstring{Jack}] \}
    ] \isa
    \textsf{List}\{ \mathit{what}\is \textsf{String}\comma  \mathit{who}\is \textsf{List String} \}\\
\end{align*}
\vspace{-40pt}
\caption{\textsf{TODO refactoring}}
\label{fig:TODO-refactor}
\end{figure}

For example a common design change is when a single value needs to become a list of multiple values. We capture this refactoring in the \textsf{ListOf} action, shown on a TODO table in Figure~\ref{fig:TODO-refactor}.
The \textsf{ListOf} action takes any type and wraps it inside a list, and wraps all corresponding values into single-element lists using the element ID $\mathbb{1}$. We will return to this example in the next section.



\section{High-fidelity version control}
In this section we build version control for simple structures that is higher fidelity than standard techniques because it is informed by the history of actions. A \textit{timeline} is an initial state and a sequence of actions executed in order that are each valid on their input state, producing an end state. Baseline records timelines by observing the actions exeuted in the API and the GUI, where actions are manifested as direct-manipulations.
%represented with the same \mathbox{\exec} notation we have been using.
We implement version control by comparing and altering timelines. These operations are built upon two primitive functions on timelines: \textsf{Project} and \textsf{Retract}.

\subsection{Projection}

% projection diagrams
\begin{figure}[h]
\begin{minipage}[b][][b]{1.75in}
\center
\begin{tikzcd}[column sep=large]
	0 & {[\mathbb{1}\is 0]} \\
	2 & {[\mathbb{1}\is 2]}
	\arrow["{{\ldotp \textsf{ ListOf}}}", from=1-1, to=1-2]
	\arrow["{{\ldotp \textsf{ write } 2}}"'{pos=0.4}, from=1-1, to=2-1]
	\arrow["{{\textsf{P}\Rightarrow}}"{description, pos=0.2}, draw=none, from=1-1, to=2-2]
	\arrow["{{\ldotp\mathbb{1} \textsf{ write } 2}}"{pos=0.4}, dashed, from=1-2, to=2-2]
	\arrow["{{\ldotp \textsf{ ListOf}}}"', dashed, from=2-1, to=2-2]
\end{tikzcd}
\\[4pt]
(a)
\end{minipage}
\quad
\begin{minipage}[b][][b]{1.75in}
\center
\begin{tikzcd}[column sep=large]
	0 & 1 \\
	2 & 2
	\arrow["{{\ldotp \textsf{ write } 1}}", from=1-1, to=1-2]
	\arrow["{{\ldotp \textsf{ write } 2}}"'{pos=0.4}, from=1-1, to=2-1]
	\arrow["{{\textsf{P}\Rightarrow}}"{description, pos=0.2}, draw=none, from=1-1, to=2-2]
	\arrow["{{\ldotp \textsf{ write } 2}}"{pos=0.4}, dashed, from=1-2, to=2-2]
	\arrow["{{\ldotp \textsf{ noop}}}"', dashed, from=2-1, to=2-2]
\end{tikzcd}
\\[4pt]
(b)
\end{minipage}
\quad
\begin{minipage}[b][][b]{1.25in}
\center
\begin{tikzcd}[column sep=large]
	\bullet & \bullet \\
	\bullet & \bullet
	\arrow["{\mathit{base}}", from=1-1, to=1-2]
	\arrow["{\mathit{pre}}"'{pos=0.4}, from=1-1, to=2-1]
	\arrow["{\textsf{P}\Rightarrow}"{description, pos=0.2}, draw=none, from=1-1, to=2-2]
	\arrow["{\mathit{post}}"{pos=0.4}, dashed, from=1-2, to=2-2]
	\arrow["{\mathit{adjust}}"', dashed, from=2-1, to=2-2]
\end{tikzcd}
\\[4pt]
(c)
\end{minipage}
\caption{\textsf{Projection}}
\label{fig:projection}
\end{figure}

The \textsf{Project} function takes as inputs two timelines with the same initial state and produces two new timelines continuing from the input timelines and converging on the same final state. It is easier to understand this with diagrams.
In Figure~\ref{fig:projection}(a) the arrow on the left takes the state $0$ (we elide the obvious type signature) and writes a $2$ over it. The arrow on the top wraps that $0$ into a list with one element $[\mathbb{1}\is 0]$. The projection function takes these two arrows as input and produces the two dashed arrows such that the diagram \textit{commutes}, meaning the dashed arrow actions are valid on the states at their bases, and they both produce the same state $[\mathbb{1}\is 2]$. The way this is acheived is to change the target path of the \textsf{write} action to follow the \textsf{ListOf} action. We say that the \textsf{write} actions have the same \textit{intention} -- they ``do the same thing'' -- they convert the $0$ to a $2$, even though the $0$ has moved to a different location. That is the key principle of projection: it produce a right-hand action that ``does the same thing'' as the left-hand action despite the top action having intervened.

Figure~\ref{fig:projection}(b) shows a messier situation. Here the left and top actions are both writing different values to the same location. This is a \textit{conflict}. The rule is that projection attempts to preserve the intention of the left action, even if that means overriding the top action, which as a consequence gets converted to a \textsf{noop} on the bottom.

This last example shows that projection is asymmetric: flipping the diagram on its diagonal to switch left and top yields a different result. And in fact we will have occasion to flip and rotate these diagrams, so we cannot depend on terminology like ``left'' and ``top''. Figure~\ref{fig:projection}(c) shows our orientation-neutral terminology: projection converts the \textit{pre} action into the \textit{post} action, preserving its intent after the \textit{base} action intervenes. The \textit{base} action is converted into the \textit{adjust} action preserving as much of its intention as is allowed by the first rule. We also graphically indicate the orientation of the diagram by placing $\textsf{P}\!\Rightarrow$ into the corner of the initial state.


% projection rules
\begin{figure}[h]
\begin{minipage}[b][][b]{1.6in}
\center
\begin{tikzcd}[column sep=large]
	\bullet & \bullet \\
	\bullet & \bullet
	\arrow["{{p \textsf{ ListOf}}}", from=1-1, to=1-2]
	\arrow["{{p \ldotp\ldotp q  \ A}}"'{pos=0.4}, from=1-1, to=2-1]
	\arrow["{{\textsf{P}\Rightarrow}}"{description, pos=0.2}, draw=none, from=1-1, to=2-2]
	\arrow["{{p \ldotp \mathbb{1} \ldotp\ldotp q \ A}}"{pos=0.4}, dashed, from=1-2, to=2-2]
	\arrow["{{p \textsf{ ListOf}}}"', dashed, from=2-1, to=2-2]
\end{tikzcd}
\\[4pt]
(a)
\end{minipage}
\quad
\begin{minipage}[b][][b]{1.7in}
\center
\begin{tikzcd}[column sep=large]
	\bullet & \bullet \\
	\bullet & \bullet
	\arrow["{{p \textsf{ write } w}}", from=1-1, to=1-2]
	\arrow["{{p \textsf{ write } v}}"'{pos=0.4}, from=1-1, to=2-1]
	\arrow["{{\textsf{P}\Rightarrow}}"{description, pos=0.2}, draw=none, from=1-1, to=2-2]
	\arrow["{{p \textsf{ write } v}}"{pos=0.4}, dashed, from=1-2, to=2-2]
	\arrow["{{p \textsf{ noop}}}"', dashed, from=2-1, to=2-2]
\end{tikzcd}
\\[4pt]
(b)
\end{minipage}
\quad
\begin{minipage}[b][][b]{1.6in}
\center
\begin{tikzcd}[column sep=large]
	\bullet & \bullet \\
	\bullet & \bullet
	\arrow["{{p \ A}}", from=1-1, to=1-2]
	\arrow["{{p \ A}}"'{pos=0.4}, from=1-1, to=2-1]
	\arrow["{{\textsf{P}\Rightarrow}}"{description, pos=0.2}, draw=none, from=1-1, to=2-2]
	\arrow["{{p \textsf{ noop}}}"{pos=0.4}, dashed, from=1-2, to=2-2]
	\arrow["{{p \textsf{ noop}}}"', dashed, from=2-1, to=2-2]
\end{tikzcd}
\\[4pt]
(c)
\end{minipage}
\caption{\textsf{Projection rules}}
\label{fig:projection-rules}
\end{figure}

We define projection with a set of rules. Figure~\ref{fig:projection-rules}(a) is a rule covering the \textsf{ListOf} example. The target path of the \textsf{ListOf} is abstracted to $p$, and the \textsf{write} action is abstracted into any action $A$ targeting $p$ or deeper, which is indicated with the path concatenation operator in $p \ldotp\ldotp q$. Action $A$ is projected down into the \textsf{ListOf} with the path $p \ldotp \mathbb{1} \ldotp\ldotp q$.

Figure~\ref{fig:projection-rules}(b) is the rule for conflicting writes. Note that the rule in (c) must override both of the rules (a) and (b) when an action is projected through an identical action. In that case we want them to cancel out into \textsf{noop} actions (see ***).


\subsection{Retraction}

% retraction diagrams
\begin{figure}[h]
\begin{minipage}[b][][b]{1.2in}
\center
\begin{tikzcd}[column sep=large]
	\bullet & \bullet \\
	\bullet & \bullet
	\arrow["{{\mathit{base}}}", from=1-1, to=1-2]
	\arrow["{{\mathit{pre}}}"'{pos=0.4}, dashed, from=1-1, to=2-1]
	\arrow["{{\Leftarrow\textsf{R}}}"{description, pos=0.2}, draw=none, from=1-2, to=2-1]
	\arrow["{{\mathit{post}}}"{pos=0.4}, from=1-2, to=2-2]
	\arrow["{{\mathit{adjust}}}"', dashed, from=2-1, to=2-2]
\end{tikzcd}
\\[4pt]
(a)
\end{minipage}
\quad
\begin{minipage}[b][][b]{1.8in}
\center
\begin{tikzcd}[column sep=large]
	0 & {[\mathbb{1}\is 0]} \\
	2 & {[\mathbb{1}\is 2]}
	\arrow["{{\ldotp \textsf{ ListOf}}}", from=1-1, to=1-2]
	\arrow["{{\ldotp \textsf{ write } 2}}"'{pos=0.4}, dashed, from=1-1, to=2-1]
	\arrow["{{\Leftarrow\textsf{R}}}"{description, pos=0.2}, draw=none, from=1-2, to=2-1]
	\arrow["{{\ldotp\mathbb{1} \textsf{ write } 2}}"{pos=0.4}, from=1-2, to=2-2]
	\arrow["{{\ldotp \textsf{ ListOf}}}"', dashed, from=2-1, to=2-2]
\end{tikzcd}
\\[4pt]
(b)
\end{minipage}
\quad
\begin{minipage}[b][][b]{1.75in}
\center
\begin{tikzcd}
	0 & {[\mathbb{1}\is 0]} \\
	{} & {[\mathbb{1}\is 2\comma e \is \textsf{NaN}]}
	\arrow["{{\ldotp \textsf{ ListOf}}}", from=1-1, to=1-2]
	% \arrow["{{}}"'{pos=0.4}, dashed, "/" marking, from=1-1, to=2-1]
	\arrow["{{\nLeftarrow\textsf{R}}}"{description, pos=0.2}, draw=none, from=1-2, to=2-1]
	\arrow["{{\ldotp \textsf{ append } e}}"{pos=0.4}, from=1-2, to=2-2]
	% \arrow["{{}}"', dashed, "/" marking, from=2-1, to=2-2]
\end{tikzcd}
\\[4pt]
(c)
\end{minipage}
\caption{\textsf{Retraction}}
\label{fig:retraction}
\end{figure}

The \textsf{Retract} function goes in the opposite direction of \textsf{Project}. Figure~\ref{fig:retraction}(a) shows that it starts with two timelines \textit{base} and \textit{post} and produces \textit{pre} and \textit{adjust}. We say that \textit{post} is retracted through \textit{base} into \textit{pre}. The goal as with projection is that \textit{pre} preserves the intention of \textit{post} before \textit{base} happened -- it ``does the same thing''. Likewise \textit{adjust} preserves the intention of \textit{base} but defers to the first rule.

Figure~\ref{fig:retraction}(b) shows the retraction reversing the projection in Figure~\ref{fig:projection}(a). Often retraction is the inverse of projection as in this case, but not always, and sometimes retraction is not possible at all. In Figure~\ref{fig:retraction}(c) the list has a new element appended to it. There is no way to do the same thing before the list was created. Projection failures indicates a \textit{dependency} between actions. The \textsf{append} action depends on the prior \textsf{ListOf} action having created the list and cannot be retracted through it.

Retraction is defined with rules like those for projection so we skip over that in the interest of brevity.


\subsection{Across the multiverse}
What are the versions that version control controls? We see them as the result of \textit{branching} timelines: two timelines that branch off of an earlier common state. We can diagram branching like this:
\[\begin{tikzcd}
	A & {} & {} & O & {} & {} & B
	\arrow["{{a_n}}"', from=1-2, to=1-1]
	\arrow[dotted, from=1-3, to=1-2]
	\arrow["{{a_1}}"', from=1-4, to=1-3]
	\arrow["{b_1}", from=1-4, to=1-5]
	\arrow[dotted, from=1-5, to=1-6]
	\arrow["{b_m}", from=1-6, to=1-7]
\end{tikzcd}\]
Here the versions are $A$ and $B$ diverging with actions $a_i$ and $b_i$ from a common state $O$. Our approach to version control is based on the ability to \textit{transport}\footnote{It is well known that a transporter can access alternate timelines\cite{mirrormirror}} an action from one branch to another, which we define digrammatically:

\[
\textsf{Transport}(a_{1\ldots n}, O, b_{1\ldots m}) = b' \textrm{ in }\quad
\begin{tikzcd}[column sep = huge]
	A_{n-1} & O & B \\
	A_n & {O'} & {B'}
	\arrow["{a_n}"', from=1-1, to=2-1]
	\arrow["{\textsf{R}\Rightarrow}"{description, pos=0.1}, draw=none, from=1-1, to=2-2]
	\arrow["{a_{n-1}\,\ldots\  a_1}"', from=1-2, to=1-1]
	\arrow["{b_1\,\ldots \  b_m}", from=1-2, to=1-3]
	\arrow["o", dashed, from=1-2, to=2-2]
	\arrow["{\textsf{P}\Rightarrow}"{description, pos=0.2}, draw=none, from=1-2, to=2-3]
	\arrow["{b'}", dashed, from=1-3, to=2-3]
	\arrow[dashed, from=2-2, to=2-1]
	\arrow[dashed, from=2-2, to=2-3]
\end{tikzcd}\]

Transportation retracts $a_n$ backwards through all earlier actions on the $A$ timeline onto the original state $O$ and then projects that action forwards through all the actions of the $B$ timeline. The final result is the action $b'$ that yields a new version $B'$. The effect of transportation is that the final action $b'$ preserves the intention of the original action $a_n$ given all the actions traversed traveling backward in time to $O$ and then forward to $B$.


As an example we extend the TODO refactoring in Figure~\ref{fig:TODO-refactor}.
\begin{align*}
  O &= [
    e \is \{ \mathit{what}\is \quotedstring{clean}\comma  \mathit{who}\is \quotedstring{Jack} \}
    ] \\
  a_1 &= e\ldotp\mathit{what}\textsf{ write } \quotedstring{tidy}\\
  a_2 &= e\ldotp\mathit{who}\textsf{ write } \quotedstring{Jill}\\
  A &= [
    e \is \{ \mathit{what}\is \quotedstring{tidy}\comma  \mathit{who}\is \quotedstring{Jill} \}
    ] \\
  b_1 &= *\ldotp \mathit{who} \textsf{ ListOf } \\
  % b_2 &= e\ldotp\mathit{who}\ldotp\mathbb{1} \textsf{ write } \quotedstring{Tom}\\
  b_2 &= e\ldotp\mathit{who} \textsf{ insert } g \textsf{ before } \mathbb{1} \\
  b_3 &= e\ldotp\mathit{who}\ldotp g \textsf{ write } \quotedstring{Tom} \\
  b_4 &= e\ldotp\mathit{who}\ldotp\mathbb{1} \textsf{ write } \quotedstring{Jacque} \\
  B &= [
    e \is \{ \mathit{what}\is \quotedstring{clean}\comma  \mathit{who}\is
    [ g \is \quotedstring{Tom} \comma \mathbb{1}\is \quotedstring{Jacque}] \}
    ] \\
\end{align*}





Transport across found diffs
Transport/transmit/teleport/port by example: pluralize, insert
porting implies changing!


Multiplicity change (Challenge \#7) with ListOf, insert, delete

building git ops out of transport?

\subsection{Galois connection}

How do we know if these rules are correct, that they do indeed preserve the intentions of actions? Our answer is that there is no objective answer to this question. The rules are essentially axioms defining what it means to preserve intention that may turn out to be more or less in agreement with intuition.
Later we propose some properties that a sound set of rules should satisfy (see ***). But nevertheless there is still a lot of freedom for design choices, particularly because of the way the rules are coupled to the set of actions. We are frankly just beginning to learn about the nature of this design space.



\subsection{Optimal branchless diffing}
beyond the repo

Conceptual model
Branching by copying
Open world of copies with no boundaries, not a DAG in a repo
Algorithm

\subsection{OT}

\begin{remark} git
Note state-based diff can't do this accurately.
rename is hopeless
like rebase, except mutates action
like cherry picking except finer grained and without problems
diffs accumulate noise.
do this after diffs?
also conceptual model
could move to related work but more relevant here
\end{remark}

\subsection{Deletion}
and tombstones. note not used currently
Ref the OT problems: https://inria.hal.science/inria-00109039/document
Explain our novel solution?
Maybe move this entirely to Appendix and take tombstones out of model.


\subsection{undo}
https://cedanet.com.au/ceda/ot/selective-undo.php
maybe appendix

Reasonable to expect inverses. Why don't I have them? Lossy operations. Undo must reconstruct loss info in a group ambler2006refactoring
Inverses of ListFrom and ListInto? ListInto wants to use first not an ID.


\section{Relationships and normalization}

beef up playable demo claims

Conjecture: first step to DB/PL unification. Ca’t find previous examples of this model. ODMG closest?

\section{Visualizing the multiverse}
\subsection{Exploring structure}
\subsection{Finding commonality}
hard problem is seeing what \textit{hasn't} changed, just moved
\subsection{Design tradeoffs}
Ultorg.
iterations on UI
\subsection{A playable demo}

\section{Queries as hypothetical timelines}
\subsection{PbD}
\subsection{Query rewriting via projection}


\section{Related work}

actually related work:
Alex's worlds. Roly. Ask them for comment?
Challenge problem paper.
I\&S: cambria, peritext, universal version control
Braid time machine https://braid.org/time-machines

\subsection{Version control}\label{VC}

git, darcs, pijul

git is the most established tool for change management but is also the source of much discontent. Pull refs from schema change paper. santiago's stuff. intentional?

Understanding Version Control as Material Interaction with Quickpose
%https://dl.acm.org/doi/10.1145/3544548.3581394

\subsection{The impedance mismatch problem} \label{impedance}

orthogonal persistence, ORMs, Linq, single tier (Tier, hop), naked objects, DBOS, durable computation

\subsection{PL state management}\label{PLstate}

FP: Monads, Lenses

Imperative: immutable, React state menagement

\subsection{OT}\label{OT}
%https://en.wikipedia.org/wiki/Operational_transformation
inclusion/exclusion transform
%https://cedanet.com.au/ceda/ot/ot-control/
forward/backward transposition %https://ieeexplore.ieee.org/document/655755

\subsection{CRDT}\label{CRDT}

\subsection{Schema Evolution}\label{schema}
just ref challenge problems paper?



\section{Discussion}
pros and cons

caveats, weaknesses, open problems

Need a rule spec language.
design alternatives for relational actions.

convergent evolution.

\section{Commencement}
summary and call to action

\printbibliography

\end{document}

% Local Variables:
% TeX-engine: luatex
% End:
